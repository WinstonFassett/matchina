---
title: State Machine Hooks
description: Use hooks to add behavior to your state machines
---

import { Tabs, TabItem } from '@astrojs/starlight/components';

## Understanding Hooks

Hooks in Matchina allow you to add behavior to your state machines at specific points in the transition lifecycle. They provide a powerful way to:

1. **Intercept transitions** before they happen
2. **Execute side effects** when entering or leaving states
3. **Orchestrate complex behavior** without cluttering your state logic
4. **Reuse logic** across different state machines

## Types of Hooks

Matchina provides several types of hooks that can be attached to state machines:

### Guard Hooks

Guard hooks prevent transitions from occurring based on certain conditions:

```ts
import { matchina, setup } from "matchina";

const counterMachine = matchina(
  {
    Low: (count: number) => ({ count }),
    Medium: (count: number) => ({ count }),
    High: (count: number) => ({ count })
  },
  {
    Low: {
      increment: (state) => 
        state.data.count + 1 < 5 
          ? { ...state, data: { count: state.data.count + 1 } }
          : "Medium"
    },
    Medium: {
      increment: (state) =>
        state.data.count + 1 < 10
          ? { ...state, data: { count: state.data.count + 1 } }
          : "High",
      decrement: (state) =>
        state.data.count - 1 > 0
          ? { ...state, data: { count: state.data.count - 1 } }
          : "Low"
    },
    High: {
      decrement: (state) =>
        state.data.count - 1 > 5
          ? { ...state, data: { count: state.data.count - 1 } }
          : "Medium"
    }
  },
  "Low",
  { count: 0 }
);

// Add a guard to prevent entering High state on weekends
setup(counterMachine, {
  guard: {
    High: () => {
      const day = new Date().getDay();
      const isWeekend = day === 0 || day === 6;
      
      // Return true to allow the transition, false to prevent it
      return !isWeekend;
    }
  }
});
```

### Enter and Leave Hooks

These hooks are triggered when entering or leaving specific states:

```ts
import { matchina, setup } from "matchina";

const authMachine = matchina(
  {
    LoggedOut: () => ({}),
    Authenticating: (username: string) => ({ username }),
    LoggedIn: (user: { id: string; name: string }) => ({ user }),
    Error: (message: string) => ({ message })
  },
  {
    LoggedOut: {
      login: (username: string, password: string) => "Authenticating"
    },
    Authenticating: {
      success: (user: { id: string; name: string }) => "LoggedIn",
      failure: (message: string) => "Error"
    },
    LoggedIn: {
      logout: "LoggedOut"
    },
    Error: {
      retry: (state) => 
        state.from?.is("Authenticating") 
          ? { key: "Authenticating", data: state.from.data }
          : "LoggedOut"
    }
  },
  "LoggedOut"
);

// Setup lifecycle hooks
setup(authMachine, {
  enter: {
    // Called when entering Authenticating state
    Authenticating: async ({ data }) => {
      try {
        const response = await fetch('/api/login', {
          method: 'POST',
          body: JSON.stringify({ username: data.username }),
          headers: { 'Content-Type': 'application/json' }
        });
        
        if (!response.ok) {
          throw new Error('Authentication failed');
        }
        
        const user = await response.json();
        authMachine.success(user);
      } catch (error) {
        authMachine.failure(error.message);
      }
    },
    // Called when entering LoggedIn state
    LoggedIn: ({ data }) => {
      // Store user in localStorage
      localStorage.setItem('user', JSON.stringify(data.user));
      // Start a session refresh timer
      const refreshInterval = setInterval(() => {
        refreshUserSession(data.user.id);
      }, 15 * 60 * 1000); // 15 minutes
      
      // Return cleanup function
      return () => clearInterval(refreshInterval);
    }
  },
  leave: {
    // Called when leaving LoggedIn state
    LoggedIn: () => {
      localStorage.removeItem('user');
    }
  }
});
```

### Effect Hooks

Effect hooks handle state machines with effect states:

```ts
import { matchina, setup, bindEffects } from "matchina";

const notificationMachine = matchina(
  {
    Idle: () => ({}),
    ShowingNotification: (message: string) => ({ message }),
    // Effect state for showing notification
    ShowNotification: (message: string) => ({ message })
  },
  {
    Idle: {
      notify: (message: string) => "ShowNotification"
    },
    ShowNotification: {
      // This is handled by the effect hook
    },
    ShowingNotification: {
      dismiss: "Idle",
      timeout: "Idle"
    }
  },
  "Idle"
);

// Handle the effect state
bindEffects(notificationMachine, {
  ShowNotification: ({ data }) => {
    // Show notification UI
    const notification = showNotification(data.message);
    
    // Transition to the showing state
    notificationMachine.transition("ShowingNotification", data.message);
    
    // Set auto-dismiss timeout
    setTimeout(() => {
      notificationMachine.timeout();
    }, 3000);
    
    // Return cleanup function if needed
    return () => {
      notification.hide();
    };
  }
});
```

## The Transition Lifecycle

When a transition occurs in a Matchina state machine, it goes through the following phases:

1. **Resolve** - Determine the next state based on the transition definition
2. **Guard** - Check if the transition should be allowed to proceed
3. **Handle** - Process the transition and prepare state changes
4. **Before** - Execute any "before" hooks
5. **Update** - Update the current state to the next state
6. **Effect** - Execute effect hooks for effect states
7. **Leave** - Execute "leave" hooks for the previous state
8. **Enter** - Execute "enter" hooks for the new state

This predictable lifecycle allows you to add behavior at exactly the right moment in the transition process.

## Combining Multiple Hooks

You can combine multiple hooks to create sophisticated behavior:

```ts
import { matchina, setup } from "matchina";

const machine = matchina(/* ... */);

setup(machine, {
  guard: {
    // Guards for specific states
  },
  enter: {
    // Enter hooks for specific states
  },
  leave: {
    // Leave hooks for specific states
  },
  before: {
    // Before hooks for specific events
  }
});
```

## Cleanup Functions

Hooks can return cleanup functions that will be called when:
- The state is exited (for enter hooks)
- A different effect is triggered (for effect hooks)
- The machine is reset or disposed

```ts
setup(machine, {
  enter: {
    Active: () => {
      const timerId = setInterval(() => {
        // Do something periodically
      }, 1000);
      
      // Return cleanup function
      return () => clearInterval(timerId);
    }
  }
});
```

## Best Practices

- **Keep hooks pure** when possible - Avoid complex side effects in guard hooks
- **Handle async operations** in enter hooks rather than transitions
- **Return cleanup functions** to prevent memory leaks
- **Use typed parameters** in your hooks for better type safety
- **Split complex logic** into multiple focused hooks

## Next Steps

Now that you understand hooks, learn more about:

- [Lifecycle Management](/guides/lifecycle) - Deeper dive into the transition lifecycle
- [Effects System](/guides/effects) - Learn more about effect states and handlers
- [React Integration](/guides/integrations) - Use hooks with React components
