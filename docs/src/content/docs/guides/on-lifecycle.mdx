---
title: Lifecycle & Hooks
description: Intercept and react to state changes with lifecycle hooks
---

import { LifecycleDemo } from "@components/LifecycleDemo";
import { Tabs, TabItem } from "@astrojs/starlight/components";

The `onLifecycle` function lets you intercept all sorts of state changes and events in your machine through a single hook call and configuration.

> **TypeScript Friendly:** All handlers are fully typed, with autocompletion for event shape and return types.

## Hook Dimensions

`onLifecycle` supports two dimensions of hooks:

| State-level hooks (top-level) | Event-level hooks (inside `on`) |
|------------------------------|---------------------------------|
| `enter`  when entering state | `before`  before event transition |
| `leave`  when leaving state  | `after`  after event transition  |
| `notify`  after state change |                                 |
| `effect`  side effects       |                                 |
| `transition`, `resolveExit`, `guard`, `update`, `handle`, `after`  advanced lifecycle hooks | |

## Wildcard Usage
You can use `"*"` for states and events to match all states or all events. For example, to run a handler for every event regardless of prior state:

```ts
onLifecycle(machine, {
  "*": {
    on: {
      "*": {
        after: (ev) => {
          // Runs after any event, from any state
        }
      }
    }
  }
});
```
You can also put event handlers like `on.executing` in the wildcard to match all prior states:
```ts
onLifecycle(machine, {
  "*": {
    on: {
      executing: { before: (ev) => {} } // runs before executing event for any state
    }
  }
});
```

## Configuration Structure

- **State names** (e.g. `Idle`, `Pending`) are top-level keys. Use `"*"` for all states.
- **Hooks** like `enter`, `leave`, and `on` go inside each state:
  - `enter`: runs when entering the state.
  - `leave`: runs when leaving the state.
  - `on`: handles events within the state.

Inside `on`, **event names** (e.g. `execute`, `reject`, `resolve`) are keys. Use `"*"` for all events.

Each event or hook can have:
- `before`: runs before the transition.
- `after`: runs after the transition.
- **Direct effect handler:** You can use a function directly for an event key, e.g. `on: { tick: (ev) => {} }` (runs as the effect hook for `tick`).

> **Direct handler invocation:** When you use a direct handler (function) for an event key, it is invoked during the entry part of the event lifecycleâ€”after update, inside effect, and after leave.

## Typing Benefits
- Handlers receive fully typed event objects, matching the machine's state/event types.
- Return types are enforced, e.g. `guard` returns boolean, `handle` returns event or undefined.
- Autocomplete and type safety for all hooks and event payloads.

## Common Patterns
- **Log every event:**
  ```ts
  onLifecycle(machine, {
    "*": {
      on: {
        "*": { after: (ev) => console.log(ev) },
        tick: (ev) => console.log("tick effect", ev), // direct effect handler
      }
    }
  });
  ```
- **Intercept only errors:**
  ```ts
  onLifecycle(machine, {
    "*": {
      on: {
        reject: { after: (ev) => console.error(ev) }
      }
    }
  });
  ```
- **Run a side effect on every state change:**
  ```ts
  onLifecycle(machine, {
    "*": {
      effect: (ev) => doSomething(ev)
    }
  });
  ```

## Interactive Example

Try adding numbers and see how lifecycle hooks log each transition below:

<div className="not-content">
  <LifecycleDemo client:only="react" />
</div>

Here's the onLifecycle logging code behind this example:

```ts
onLifecycle(machine, {
  Idle: {
    on: {
      executing: (ev) => {
        console.log("Idle.executing effect:", ev.type, ev.from.key, ev.to.key);
      },
      // Old style still works:
      resolve: {
        before: ({ type, from, to, params }) => {
          console.log("before Idle.resolve:", type, from.key, to.key, Object.keys(params));
        },
      },
    },
  },
  "*": {
    on: {
      "*": {
        after: (ev) => {
          console.log(`[${ev.type}]:`, ev.to.key, ev.to.data);
        },
      },
      reject: {
        after: ({ type, from, to }) => {
          const { name, stack, message } = to.data;
          console.log("after", type, "from", from.key, name, message, stack);
        },
      },
      resolve: {
        before: ({ type, from: _from, to: { data } }) => {
          console.log("before", type, data);
        },
      },
    },
  },
});
```

## Next Steps

Now that you understand lifecycle hooks, explore these related guides:

- [Effects](/guides/effects) - Learn about the dedicated effects system
- [Factory Machines](/guides/machines) - Create complete state machines
- [Promise Machines](/guides/promises) - Handle async operations with state machines
- [React Integration](/guides/integrations) - Use lifecycle hooks with React
- [API Reference](/api/onLifecycle) - Full API details for `onLifecycle`
