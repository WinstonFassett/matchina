---
title: React Integration
description: Use Matchina state machines with React components
---

import { Tabs, TabItem } from '@astrojs/starlight/components';

## React Hooks for Matchina

Matchina provides React hooks that make it easy to use state machines in your React components. These hooks provide:

1. **Automatic re-rendering** when machine state changes
2. **Type-safe access** to state and transitions
3. **Lifecycle management** for event handlers
4. **Performance optimizations** to prevent unnecessary renders

## The useMachine Hook

The basic hook for using a machine in React is `useMachine`:

```tsx
import { useMachine } from "matchina/react";
import { matchina } from "matchina";

// Create a counter machine
const counterMachine = matchina(
  {
    Idle: () => ({ count: 0 }),
    Counting: (count: number) => ({ count })
  },
  {
    Idle: { 
      start: "Counting" 
    },
    Counting: {
      increment: (state) => ({
        ...state, 
        data: { count: state.data.count + 1 }
      }),
      decrement: (state) => ({
        ...state, 
        data: { count: Math.max(0, state.data.count - 1) }
      }),
      reset: "Idle"
    }
  },
  "Idle"
);

// Use the machine in a React component
function Counter() {
  // Subscribe to the machine state
  useMachine(counterMachine);
  
  return (
    <div>
      {counterMachine.state.match({
        Idle: () => (
          <>
            <p>Counter is idle</p>
            <button onClick={() => counterMachine.start()}>
              Start Counting
            </button>
          </>
        ),
        Counting: ({ count }) => (
          <>
            <p>Count: {count}</p>
            <button onClick={() => counterMachine.increment()}>
              Increment
            </button>
            <button onClick={() => counterMachine.decrement()}>
              Decrement
            </button>
            <button onClick={() => counterMachine.reset()}>
              Reset
            </button>
          </>
        )
      })}
    </div>
  );
}
```

## The useLifecycle Hook

For more advanced lifecycle management, you can use the `useLifecycle` hook:

```tsx
import { useLifecycle } from "matchina/react";
import { matchina } from "matchina";

// Create a todo machine
const todoMachine = matchina(
  {
    Empty: () => ({}),
    Active: (todos: string[]) => ({ todos }),
    Saving: (todos: string[]) => ({ todos }),
    Error: (message: string) => ({ message })
  },
  {
    Empty: {
      add: (todo: string) => "Active"
    },
    Active: {
      add: (todo: string, state) => ({
        ...state,
        data: { todos: [...state.data.todos, todo] }
      }),
      remove: (index: number, state) => {
        const newTodos = [...state.data.todos];
        newTodos.splice(index, 1);
        return newTodos.length === 0 
          ? "Empty" 
          : { ...state, data: { todos: newTodos } };
      },
      save: "Saving"
    },
    Saving: {
      success: "Active",
      error: (message: string) => "Error"
    },
    Error: {
      dismiss: (state) => 
        state.from?.is("Saving") 
          ? { key: "Active", data: state.from.data } 
          : "Empty"
    }
  },
  "Empty"
);

// Todo component using the machine with lifecycle hooks
function TodoApp() {
  const [newTodo, setNewTodo] = React.useState('');
  const [machine, lifecycle] = useLifecycle(todoMachine);
  
  // Register lifecycle hook for the Saving state
  lifecycle.onEnter("Saving", ({ data }) => {
    // Simulate API call
    setTimeout(() => {
      if (Math.random() > 0.8) {
        machine.error("Failed to save todos");
      } else {
        machine.success();
      }
    }, 1000);
  });
  
  return (
    <div>
      <h1>Todo App</h1>
      
      <form onSubmit={e => {
        e.preventDefault();
        if (newTodo.trim()) {
          machine.add(newTodo);
          setNewTodo('');
        }
      }}>
        <input 
          value={newTodo} 
          onChange={e => setNewTodo(e.target.value)} 
          placeholder="New todo"
        />
        <button type="submit">Add</button>
      </form>
      
      {machine.state.match({
        Empty: () => (
          <p>No todos yet. Add one to get started!</p>
        ),
        Active: ({ todos }) => (
          <>
            <ul>
              {todos.map((todo, index) => (
                <li key={index}>
                  {todo}
                  <button onClick={() => machine.remove(index)}>Remove</button>
                </li>
              ))}
            </ul>
            <button onClick={machine.save}>Save</button>
          </>
        ),
        Saving: () => (
          <p>Saving todos...</p>
        ),
        Error: ({ message }) => (
          <div className="error">
            <p>Error: {message}</p>
            <button onClick={machine.dismiss}>Dismiss</button>
          </div>
        )
      })}
    </div>
  );
}
```

## Using Promise Machines with React

Promise machines work particularly well with React for handling async operations:

```tsx
import { createPromiseMachine } from "matchina";
import { useMachine } from "matchina/react";
import { useMemo, useState } from "react";

function DataFetcher() {
  const [userId, setUserId] = useState("");
  
  // Create a promise machine for data fetching
  const fetcher = useMemo(() => createPromiseMachine(
    async (id: string) => {
      const response = await fetch(`https://jsonplaceholder.typicode.com/users/${id}`);
      if (!response.ok) throw new Error(`Failed to fetch: ${response.status}`);
      return response.json();
    }
  ), []);
  
  // Subscribe to the machine state
  useMachine(fetcher);
  
  const handleSubmit = (e) => {
    e.preventDefault();
    if (userId) {
      fetcher.execute(userId);
    }
  };
  
  return (
    <div>
      <h2>User Fetcher</h2>
      
      <form onSubmit={handleSubmit}>
        <input
          value={userId}
          onChange={e => setUserId(e.target.value)}
          placeholder="Enter user ID"
        />
        <button type="submit">Fetch User</button>
      </form>
      
      <div className="result">
        {fetcher.getState().match({
          Idle: () => <p>Enter a user ID and click Fetch</p>,
          Pending: ({params}) => <p>Loading user {params[0]}...</p>,
          Resolved: (user) => (
            <div>
              <h3>{user.name}</h3>
              <p>Email: {user.email}</p>
              <p>Phone: {user.phone}</p>
              <p>Website: {user.website}</p>
            </div>
          ),
          Rejected: (error) => <p className="error">Error: {error.message}</p>
        })}
      </div>
    </div>
  );
}
```

## Performance Considerations

### Preventing Unnecessary Renders

When using state machines with React, consider these tips for better performance:

1. **Memoize machine creation** with `useMemo` when machine definition depends on props
2. **Use selective rendering** with pattern matching to only render what's needed
3. **Extract complex components** into separate components to limit re-renders

```tsx
// Good - Selective rendering with pattern matching
function UserView() {
  useMachine(userMachine);
  
  // Only the relevant section will re-render when state changes
  return (
    <div>
      <Header /> {/* Won't re-render on state changes */}
      <Sidebar /> {/* Won't re-render on state changes */}
      
      {userMachine.state.match({
        Loading: () => <LoadingSpinner />,
        Error: ({ message }) => <ErrorMessage message={message} />,
        LoggedIn: (user) => <UserProfile user={user} />,
        LoggedOut: () => <LoginForm onLogin={userMachine.login} />
      })}
    </div>
  );
}
```

## Next Steps

Now that you understand React integration, explore these related guides:

- [Promises](/guides/promises) - Learn more about promise machines
- [Lifecycle](/guides/lifecycle) - Understand the full lifecycle system
- [Effects](/guides/effects) - Manage side effects with state machines
