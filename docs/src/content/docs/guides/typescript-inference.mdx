---
title: TypeScript Inference Best Practices
description: Learn how to get the most out of TypeScript's type inference with Matchina
---

import { Tabs, TabItem } from "@astrojs/starlight/components";
import CodeTabs from "@components/CodeTabs.astro";
import usageInferenceFull from "@code/examples/usage-inference-full.ts?raw";
import usageInferenceBroken from "@code/examples/usage-inference-broken.ts?raw";

## Introduction

One of Matchina's greatest strengths is its excellent TypeScript support. However, to get the most out of the type system, there are certain patterns you should follow and others you should avoid. This guide explains how to maintain full type inference when working with Matchina state machines.

## Transition Types and Options

Matchina supports multiple formats for transitions, with full type inference when defined inline:

Each transition can be defined in several ways:

1. A simple string with the target state name
2. A function that returns a state name
3. A function that returns a complete state object
4. A function that accepts the current state and returns a new state

The TypeScript compiler ensures that all transitions are valid and that any parameters match the requirements of the target state.

## Transition Types in Matchina

Matchina supports several forms of transitions, each with different levels of customization:

### Different forms of transitions

```ts
// 1. Simple string transition (target state with no parameters)
"TargetState"

// 2. Function returning a state or state name (can compute target state dynamically)
(...params) => "TargetState"
(...params) => states.TargetState(...moreParams)

// 3. Parameterized function can also return a transformer that takes the current event and returns a new state
(...params) => (event) => states.TargetState(...moreParams)
```

## Recommended Patterns

### Inline Transitions

For full type inference to work properly, these transitions should be defined inside `createMachine()` rather than as standalone objects.

Benefits of this approach:

- Full type checking between states and transitions
- Autocomplete for state names in transitions
- Parameter type checking for transition functions
- Prevents common errors like typos in state names

Compare the type support for inline transitions versus standalone transition objects:

<CodeTabs
  files={[
    {
      name: "usage-inference-full.ts",
      code: usageInferenceFull,
      lang: "ts",
      twoslash: true,
    },
    {
      name: "usage-inference-broken.ts",
      code: usageInferenceBroken,
      lang: "ts",
      twoslash: true,
    },
  ]}
/>

## Developer Experience Benefits

Using the recommended patterns gives you:

1. **Better autocompletion**: IDE suggestions for state names when defining transitions
2. **Immediate feedback**: Errors are caught during development instead of at runtime
3. **Refactoring support**: Renaming states will automatically flag outdated transitions
4. **Parameter validation**: TypeScript checks that transition parameters match state requirements

## Summary

To ensure the best developer experience with Matchina:

1. \*\*Define transitions inside `createMachine` function call
2. **Avoid standalone transition objects**: These break TypeScript's ability to validate your code
3. **Let TypeScript help you**: Embrace the rich type checking and autocomplete features

Following these practices will help you catch errors earlier, write more reliable code, and get the most out of Matchina's TypeScript integration.
