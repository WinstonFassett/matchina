---
title: Matchbox - Type-Safe Tagged Unions
description: Learn about the foundational concept of Matchbox for creating type-safe tagged unions in TypeScript
---

import CodeBlock from "@components/CodeBlock.astro";
import { Tabs, TabItem } from '@astrojs/starlight/components';

## What are Tagged Unions?

Tagged unions (also known as discriminated unions or sum types) are a powerful pattern in TypeScript for creating types that can be one of several variants, each with its own shape. The "tag" is a common property that identifies which variant the object is.

Matchbox is Matchina's implementation of tagged unions with powerful pattern matching and type guards.

## Creating Tagged Unions with Matchbox

The `matchbox` function creates a factory for type-safe tagged unions:

```ts
import { matchbox } from "matchina";

// Create a state factory with typed data for each state
const Shape = matchbox({
  Circle: (radius: number) => ({ radius }),
  Rectangle: (width: number, height: number) => ({ width, height }),
  Triangle: (base: number, height: number) => ({ base, height }),
});

// Type-safe state creation:
const circle = Shape.Circle(5);
const rectangle = Shape.Rectangle(10, 20);
const triangle = Shape.Triangle(15, 8);

// TypeScript knows the type of each shape
console.log(circle.key);       // "Circle"
console.log(rectangle.data);   // { width: 10, height: 20 }
```


## Practical Applications

Matchbox can be used in many scenarios where you need to handle different variants of a type:

### 1. API Response Handling

```ts
const ApiResponse = matchbox({
  Success: (data: any) => ({ data }),
  Error: (code: number, message: string) => ({ code, message }),
  Loading: () => ({}),
});

function handleResponse(response) {
  return response.match({
    Success: ({ data }) => renderData(data),
    Error: ({ code, message }) => showError(code, message),
    Loading: () => showSpinner(),
  });
}
```

### 2. Form State Management

```ts
const FormState = matchbox({
  Initial: () => ({}),
  Editing: (values: Record<string, any>, isDirty: boolean = true) => ({ values, isDirty }),
  Submitting: (values: Record<string, any>) => ({ values }),
  Success: (values: Record<string, any>) => ({ values }),
  Error: (values: Record<string, any>, error: string) => ({ values, error }),
});

// Usage
let state = FormState.Initial();

// User starts editing
state = FormState.Editing({ name: "John", email: "" });

// Validation before submission
if (state.is("Editing") && !state.data.values.email) {
  state = FormState.Error(state.data.values, "Email is required");
} else if (state.is("Editing")) {
  state = FormState.Submitting(state.data.values);
  // Submit to server...
}
```

### 3. State Machines Foundation

Matchbox forms the foundation for Matchina's state machines:

```ts
import { matchbox, createMachine } from "matchina";

// Create a state factory
const AuthState = matchbox({
  LoggedOut: () => ({}),
  LoggingIn: (username: string) => ({ username }),
  LoggedIn: (username: string, token: string) => ({ username, token }),
  Error: (message: string) => ({ message }),
});

// Create a state machine using the factory
const authMachine = createMachine(
  AuthState,
  {
    LoggedOut: {
      login: (username: string, password: string) => "LoggingIn"
    },
    LoggingIn: {
      success: (token: string) => (state) => 
        AuthState.LoggedIn(state.data.username, token),
      failure: (message: string) => "Error"
    },
    LoggedIn: {
      logout: "LoggedOut"
    },
    Error: {
      retry: "LoggedOut"
    }
  },
  AuthState.LoggedOut()
);
```

## Extending Tagged Unions

You can extend Matchbox factories with methods for more functionality:

```ts
// Extend Shape with area calculation methods
const ShapeWithArea = {
  ...Shape,
  getArea: (shape) => shape.match({
    Circle: ({ radius }) => Math.PI * radius * radius,
    Rectangle: ({ width, height }) => width * height,
    Triangle: ({ base, height }) => (base * height) / 2,
  })
};

// Usage
const myCircle = ShapeWithArea.Circle(5);
console.log(ShapeWithArea.getArea(myCircle));  // 78.54...
```

## Next Steps

Now that you understand Matchbox for tagged unions, you can:

- [Explore Factory Machines](./machines/) - Learn how to build full state machines with transitions
- [Master Type Guards](./typeguards/) - Dive deeper into type guards and type narrowing
- [Try Lifecycle Hooks](./lifecycle/) - Add hooks for intercepting state changes
