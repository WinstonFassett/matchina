---
title: Matchbox (Tagged Unions)
description: "Matchbox: a powerful tagged union system with complete type inference"
---

import { Tabs, TabItem } from '@astrojs/starlight/components';
import CodeBlock from '@components/CodeBlock.astro';

import lightBasicRaw from '../../../code/examples/matchbox-usage/light-basic.ts?raw';
import lightPatternMatchingRaw from '../../../code/examples/matchbox-usage/light-pattern-matching.ts?raw';
import lightTypeGuardsRaw from '../../../code/examples/matchbox-usage/light-type-guards.ts?raw';
import lightDefaultCaseRaw from '../../../code/examples/matchbox-usage/light-default-case.ts?raw';
import lightCastingRaw from '../../../code/examples/matchbox-usage/light-casting.ts?raw';
import lightCustomTagRaw from '../../../code/examples/matchbox-usage/light-custom-tag.ts?raw';
import lightAdvancedMatchingRaw from '../../../code/examples/matchbox-usage/light-advanced-matching.ts?raw';
import tsNativeUnionRaw from '../../../code/examples/matchbox-usage/ts-native-union.ts?raw';
import defaultCaseRaw from '../../../code/examples/matchbox-usage/default-case.ts?raw';
import nonExhaustiveRaw from '../../../code/examples/matchbox-usage/non-exhaustive.ts?raw';
import typeGuardsRaw from '../../../code/examples/matchbox-usage/type-guards.ts?raw';

# Matchbox: Tagged Unions

Matchbox is a powerful system for creating and working with tagged unions in TypeScript, providing type-safe pattern matching, exhaustiveness checking, and comprehensive type inference.

## What are Tagged Unions?

Tagged unions (also known as discriminated unions or sum types) are a powerful way to represent data that can be one of several distinct types, each with its own structure:

<CodeBlock code={tsNativeUnionRaw} lang="ts" twoslash={true} />

## Why Matchbox?

While TypeScript has built-in support for discriminated unions, Matchbox adds powerful capabilities:

1. **Factory Functions** - Create instances of union variants with proper typing
2. **Pattern Matching** - Match against union variants with exhaustiveness checking
3. **Type Predicates** - Built-in type guards with the `is` method
4. **Type Assertion** - Convert between variants with the `as` method
5. **Complete Type Inference** - Full inference with minimal type annotations

## Creating a Matchbox

You can create a matchbox using the `matchboxFactory` function:

<CodeBlock code={lightBasicRaw} lang="ts" twoslash={true} />

## Pattern Matching

The most powerful feature of Matchbox is exhaustive pattern matching with the `match` method:

<CodeBlock code={lightPatternMatchingRaw} lang="ts" twoslash={true} />

## Type Guards

Matchbox provides automatic type narrowing with the `is` method:

<CodeBlock code={lightTypeGuardsRaw} lang="ts" twoslash={true} />

## Using Default Cases

Sometimes you want to handle multiple states with a single case, or provide a fallback:

<CodeBlock code={lightDefaultCaseRaw} lang="ts" twoslash={true} />

## Non-Exhaustive Matching

You can opt-out of exhaustiveness checking by passing `false` as the second argument:

<CodeBlock code={nonExhaustiveRaw} lang="ts" twoslash={true} />

## Type Casting

Use the `as` method for type-safe casting with runtime validation:

<CodeBlock code={lightCastingRaw} lang="ts" twoslash={true} />

## Custom Tag Property

By default, the tag property is named `tag`, but you can customize it:

<CodeBlock code={lightCustomTagRaw} lang="ts" twoslash={true} />

## Advanced Pattern Matching

Matchbox can handle complex scenarios with nested data:

<CodeBlock code={lightAdvancedMatchingRaw} lang="ts" twoslash={true} />

## Conclusion

Matchbox provides a powerful way to work with tagged unions in TypeScript, offering better type safety, pattern matching, and developer experience than plain TypeScript discriminated unions.

The key advantages are:
- Factory functions for creating properly typed variants
- Exhaustive pattern matching
- Built-in type guards and assertions
- Excellent type inference

This makes complex state modeling and data handling more robust and maintainable, with TypeScript helping to catch errors at compile time rather than runtime.
