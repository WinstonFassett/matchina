---
title: Matchbox Usage
description: Learn how to use Matchbox factories for type-safe operations and pattern matching
---

import CodeBlock from "@components/CodeBlock.astro";
import code from "@code/examples/usage-typeguards.ts?raw";
import { Tabs, TabItem } from "@astrojs/starlight/components";

import lightBasicRaw from "../../../code/examples/matchbox-usage/light-basic.ts?raw";
import lightPatternMatchingRaw from "../../../code/examples/matchbox-usage/light-pattern-matching.ts?raw";
import lightTypeGuardsRaw from "../../../code/examples/matchbox-usage/light-type-guards.ts?raw";
import lightDefaultCaseRaw from "../../../code/examples/matchbox-usage/light-default-case.ts?raw";
import lightCastingRaw from "../../../code/examples/matchbox-usage/light-casting.ts?raw";
import lightCustomTagRaw from "../../../code/examples/matchbox-usage/light-custom-tag.ts?raw";
import lightAdvancedMatchingRaw from "../../../code/examples/matchbox-usage/light-advanced-matching.ts?raw";
import matchSetupRaw from "../../../code/examples/matchbox-usage/match-setup.ts?raw";
import matchRaw from "../../../code/examples/matchbox-usage/match.ts?raw";
import matchWithDefaultRaw from "../../../code/examples/matchbox-usage/match-with-default.ts?raw";
import matchNonExhaustiveRaw from "../../../code/examples/matchbox-usage/match-non-exhaustive.ts?raw";
import tsNativeUnionRaw from "../../../code/examples/matchbox-usage/ts-native-union.ts?raw";
import defaultCaseRaw from "../../../code/examples/matchbox-usage/default-case.ts?raw";
import nonExhaustiveRaw from "../../../code/examples/matchbox-usage/non-exhaustive.ts?raw";
import typeGuardsRaw from "../../../code/examples/matchbox-usage/type-guards.ts?raw";


## Handle cases with `match()`

One of the most powerful features of Matchbox is exhaustive pattern matching with the `match` method, serving as an alternative to `switch` statements that are not guaranteed to be exhaustive.

Given the following matchbox factory:

<CodeBlock code={matchSetupRaw} lang="ts" twoslash={false} />

### Pattern Matching with Exhaustive Checking


The most powerful feature of tagged unions created with `matchboxFactory` is exhaustive pattern matching with the `match` method:

<CodeBlock code={matchRaw} lang="ts" twoslash={true} />

### Using Default Cases

Sometimes you want to handle multiple states with a single case, or provide a fallback:

<CodeBlock code={matchWithDefaultRaw} lang="ts" twoslash={true} />

### Non-Exhaustive Matching

You can opt-out of exhaustiveness checking by passing `false` as the second argument:

<CodeBlock code={matchNonExhaustiveRaw} lang="ts" twoslash={true} />


## Type Guards

Using type guards in Matchbox provides several benefits:

- **Type safety**: Prevent runtime errors by catching type mismatches at compile time
- **Code completion**: Get proper IDE suggestions based on narrowed types
- **Refactoring safety**: When you change a state's structure, TypeScript will flag all places that need updates
- **Exhaustive checking**: Ensure all possible states are handled with pattern matching


### Type Narrow using `is()`

Tagged union instances created with `matchboxFactory` provide automatic type narrowing with the `is` method:

<CodeBlock code={lightTypeGuardsRaw} lang="ts" twoslash={true} />

### Cast using `as()`

Use the `as` method for type-safe casting with runtime validation:

<CodeBlock code={lightCastingRaw} lang="ts" twoslash={true} />

### Filter using with Type Predicates

Matchina also provides filter functions for more complex type guards:

```ts
import { matchbox, withKey, withData } from "matchina";
// ---cut---
const Shape = matchbox({
  Circle: (radius: number, color: string = "black") => ({ radius, color }),
  Rectangle: (width: number, height: number, color: string = "black") => ({
    width,
    height,
    color,
  }),
  Triangle: (base: number, height: number, color: string = "black") => ({
    base,
    height,
    color,
  }),
});

const shapes = [
  Shape.Circle(5, "red"),
  Shape.Rectangle(10, 20, "blue"),
  Shape.Circle(8, "green"),
  Shape.Triangle(15, 10, "red"),
];

// Filter by key
const circles = shapes.filter(withKey("Circle"));
console.log(`Found ${circles.length} circles`);

// Filter by data property
const redShapes = shapes.filter(withData((data) => data.color === "red"));
console.log(`Found ${redShapes.length} red shapes`);

// Combine filters
const largeCircles = shapes.filter(
  (shape) => shape.is("Circle") && shape.data.radius > 7,
);
console.log(`Found ${largeCircles.length} large circles`);
````


## Next Steps

Now that you understand type guards, explore these related guides:

- [Matchbox: Type-Safe Unions](/matchina/union-machines/) - Learn more about the foundation of type guards
- [Factory Machines](/matchina/machines/) - See how type guards work with state machines
- [Lifecycle Hooks](/matchina/lifecycle/) - Add hooks for intercepting state changes
