---
title: Factory Machines
description: Create complete state machines with TypeScript inference and type-safe transitions
---

import { Tabs, TabItem } from '@astrojs/starlight/components';
import MachineDemo from "@components/MachineDemo.astro";

## What are Factory Machines?

Factory Machines combine state factories with transitions to create complete state machines with type-safe operations. They extend the Matchbox pattern to provide:

1. **Type-safe state creation** with proper parameter inference
2. **Type-safe transitions** with smart parameter types
3. **State data preservation** when transitioning between states
4. **Lifecycle hooks** for intercepting and reacting to state changes

```ts 
  const {(getState, send)} = fsm(states, transitions, initialState) 
```

## Creating Factory Machines

There are two ways to create a factory machine:

<Tabs>
  <TabItem label="Using defineStates">
```ts
import { defineStates, createMachine } from "matchina";

// 1. Define state factory
const TaskStates = defineStates({
  Idle: () => ({}),
  Loading: (query: string) => ({ query }),
  Success: (query: string, results: string[]) => ({ query, results }),
  Error: (query: string, message: string) => ({ query, message })
});

// 2. Create a factory machine with type-safe transitions
const taskMachine = createMachine(
  TaskStates,
  {
    Idle: { 
      // Parameter types are inferred from the destination state
      search: (query: string) => "Loading"
    },
    Loading: {
      // Parameter types are inferred from the destination state
      success: (results: string[]) => (state) => {
        // TypeScript knows state.data has query from Loading state
        return TaskStates.Success(state.data.query, results);
      },
      // Parameter types are inferred from the destination state
      error: (message: string) => (state) => {
        // TypeScript knows state.data has query from Loading state
        return TaskStates.Error(state.data.query, message);
      }
    },
    Success: {
      // Return to idle state
      reset: "Idle",
      // Start a new search
      search: (query: string) => "Loading"
    },
    Error: {
      // Return to idle state
      reset: "Idle",
      // Retry the same query
      retry: (state) => {
        // TypeScript knows state.data has query from Error state
        return TaskStates.Loading(state.data.query);
      }
    }
  },
  // 3. Set initial state
  TaskStates.Idle()
);
```
  </TabItem>
  <TabItem label="Using matchina">
```ts
import { matchina } from "matchina";

// Create a state machine directly with matchina
const taskMachine = matchina(
  // 1. Define states
  {
    Idle: undefined,
    Loading: (query: string) => ({ query }),
    Success: (query: string, results: string[]) => ({ query, results }),
    Error: (query: string, message: string) => ({ query, message })
  },
  // 2. Define transitions
  {
    Idle: { 
      search: (query: string) => "Loading" 
    },
    Loading: {
      success: (results: string[]) => "Success",
      error: (message: string) => "Error"
    },
    Success: {
      reset: "Idle",
      search: (query: string) => "Loading"
    },
    Error: {
      reset: "Idle",
      retry: (state) => "Loading"
    }
  },
  // 3. Set initial state
  "Idle"
);
```
  </TabItem>
</Tabs>

## Transition Types

Factory machine transitions are defined as an object mapping each state key to a set of event handlers. Each event handler can be one of three forms, as described by the type:

```ts
export type FactoryMachineTransitions<SF extends AnyStatesFactory> = object & {
  [FromStateKey in string & keyof SF]?: {
    [EventKey in string]?: FactoryMachineTransition<SF, FromStateKey, EventKey>;
  };
};

export type FactoryMachineTransition<
  SF extends AnyStatesFactory,
  FromStateKey extends keyof SF = keyof SF,
  EventKey extends string = any,
> =
  | keyof SF
  | ((...params: any[]) => FactoryState<SF>)
  | ((...params: any[]) => (
      ev: ResolveEvent<
        FactoryMachineEvent<{ states: SF; transitions: any }>
      > & {
        from: FactoryState<SF, FromStateKey>;
      },
    ) => FactoryState<SF>);
```

### 1. String Transitions (State Key)

Transition to another state by returning the state key as a string. Data is preserved if compatible.

```ts
{
  Playing: {
    pause: "Paused" // Transition to Paused state
  }
}
```

### 2. Function Transitions (With Parameters)

Transition by returning a new state using a function that takes parameters. This is useful for passing data to the next state.

```ts
{
  Idle: {
    search: (query: string) => TaskStates.Loading(query)
  }
}
```

### 3. Event Object Transitions (Full Control)

Transition by returning a new state using a function that receives an event object, which includes the event parameters and the `from` state. This allows for advanced logic and full access to the previous state and event data.

```ts
{
  Loading: {
    success: (results: string[]) => (ev) => {
      // ev.from is the previous state
      // ev contains event parameters
      return TaskStates.Success(ev.from.data.query, results);
    }
  }
}
```

**Summary Table:**

| Form                | Example                                      | Use Case                                 |
|---------------------|----------------------------------------------|------------------------------------------|
| String (state key)  | `pause: "Paused"`                            | Simple state change, preserve data       |
| Function            | `search: (q) => TaskStates.Loading(q)`       | Pass parameters to next state            |
| Event object        | `success: (r) => (ev) => ...`                | Full access to event and previous state  |

## Using Factory Machines

Once you've created a factory machine, you can use its API:

### 1. Triggering Transitions

Call transition methods with proper parameters:

```ts
// Call transition with required parameters
taskMachine.search("react hooks");

// When in Loading state, call success with results
if (taskMachine.getState().is("Loading")) {
  taskMachine.success(["result1", "result2"]);
}
```

### 2. Getting Current State

Get the current state for inspection:

```ts
const state = taskMachine.getState();
console.log(state.key);  // Current state key

// Use type guards
if (state.is("Success")) {
  console.log(state.data.results);  // Type-safe access to results
}
```

### 3. Pattern Matching

Use pattern matching for exhaustive state handling:

```ts
const ui = taskMachine.getState().match({
  Idle: () => "Enter a search term",
  Loading: ({ query }) => `Searching for "${query}"...`,
  Success: ({ query, results }) => 
    `Found ${results.length} results for "${query}": ${results.join(", ")}`,
  Error: ({ query, message }) => 
    `Error searching for "${query}": ${message}`
});
```

## Advanced Pattern: Preserving State Data

Transitions often need to preserve data from the previous state. There are multiple ways to do this, matching the allowed transition forms:

### 1. Using String Transitions (Auto Preservation)

```ts
// When data types are compatible, data is automatically preserved
{
  Playing: {
    pause: "Paused"  // trackId is preserved from Playing to Paused
  }
}
```

### 2. Using Event Object in Function Transitions

The function receives a change event object `{ type, from, to }`, giving you access to the previous state and event type.

```ts
{
  Error: {
    retry: (event) => {
      // event: { type, from, to }
      // Access previous state data via event.from
      return "Loading";  // Original query is preserved
    }
  }
}
```

### 3. Using State Factory for Complete Control

For the most control, return a function that receives the event object and returns a new state using the state factory:

```ts
{
  Loading: {
    success: (results: string[]) => (event) => {
      // event: { type, from, to }
      // Use state factory with data from current state
      return TaskStates.Success(event.from.data.query, results);
    }
  }
}
```

## Next Steps

Now that you understand Factory Machines, explore these related guides:

- [Lifecycle & Hooks](./lifecycle/) - Add hooks for intercepting state changes
- [Effects](./effects/) - Manage side effects with the effects system
- [Promise Machines](./promises/) - Handle async operations with state machines
- [React Integration](./integrations/) - Use state machines with React
