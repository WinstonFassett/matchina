---
title: Factory Machines
description: Create complete state machines with TypeScript inference and type-safe transitions
---

import { Tabs, TabItem } from '@astrojs/starlight/components';
import MachineDemo from "@components/MachineDemo.astro";

## What are Factory Machines?

Factory Machines combine state factories with transitions to create complete state machines with type-safe operations. They extend the Matchbox pattern to provide:

1. **Type-safe state creation** with proper parameter inference
2. **Type-safe transitions** with smart parameter types
3. **State data preservation** when transitioning between states
4. **Lifecycle hooks** for intercepting and reacting to state changes

```ts 
  const {(getState, send)} = fsm(states, transitions, initialState) 
```

## Creating Factory Machines

There are two ways to create a factory machine:

<Tabs>
  <TabItem label="Using defineStates">
```ts
import { defineStates, createFactoryMachine } from "matchina";

// 1. Define state factory
const TaskStates = defineStates({
  Idle: () => ({}),
  Loading: (query: string) => ({ query }),
  Success: (query: string, results: string[]) => ({ query, results }),
  Error: (query: string, message: string) => ({ query, message })
});

// 2. Create a factory machine with type-safe transitions
const taskMachine = createFactoryMachine(
  TaskStates,
  {
    Idle: { 
      // Parameter types are inferred from the destination state
      search: (query: string) => "Loading"
    },
    Loading: {
      // Parameter types are inferred from the destination state
      success: (results: string[]) => (state) => {
        // TypeScript knows state.data has query from Loading state
        return TaskStates.Success(state.data.query, results);
      },
      // Parameter types are inferred from the destination state
      error: (message: string) => (state) => {
        // TypeScript knows state.data has query from Loading state
        return TaskStates.Error(state.data.query, message);
      }
    },
    Success: {
      // Return to idle state
      reset: "Idle",
      // Start a new search
      search: (query: string) => "Loading"
    },
    Error: {
      // Return to idle state
      reset: "Idle",
      // Retry the same query
      retry: (state) => {
        // TypeScript knows state.data has query from Error state
        return TaskStates.Loading(state.data.query);
      }
    }
  },
  // 3. Set initial state
  TaskStates.Idle()
);
```
  </TabItem>
  <TabItem label="Using matchina">
```ts
import { matchina } from "matchina";

// Create a state machine directly with matchina
const taskMachine = matchina(
  // 1. Define states
  {
    Idle: undefined,
    Loading: (query: string) => ({ query }),
    Success: (query: string, results: string[]) => ({ query, results }),
    Error: (query: string, message: string) => ({ query, message })
  },
  // 2. Define transitions
  {
    Idle: { 
      search: (query: string) => "Loading" 
    },
    Loading: {
      success: (results: string[]) => "Success",
      error: (message: string) => "Error"
    },
    Success: {
      reset: "Idle",
      search: (query: string) => "Loading"
    },
    Error: {
      reset: "Idle",
      retry: (state) => "Loading"
    }
  },
  // 3. Set initial state
  "Idle"
);
```
  </TabItem>
</Tabs>

## Transition Types

Factory machines support different kinds of transitions:

### 1. String Transitions

The simplest form that preserves compatible data:

```ts
{
  Playing: {
    pause: "Paused"  // Simple transition to Paused state
  }
}
```

### 2. Function Transitions

Return a string for the target state:

```ts
{
  Idle: {
    search: (query: string) => "Loading"  // With parameters
  }
}
```

### 3. State Factory Transitions

Return a new state using the state factory:

```ts
{
  Loading: {
    success: (results: string[]) => (state) => {
      return TaskStates.Success(state.data.query, results);
    }
  }
}
```

### 4. State Update Transitions

Return a modified version of the current state:

```ts
{
  Counting: {
    increment: (state) => ({
      ...state,
      data: { count: state.data.count + 1 }
    })
  }
}
```

## Using Factory Machines

Once you've created a factory machine, you can use its API:

### 1. Triggering Transitions

Call transition methods with proper parameters:

```ts
// Call transition with required parameters
taskMachine.search("react hooks");

// When in Loading state, call success with results
if (taskMachine.getState().is("Loading")) {
  taskMachine.success(["result1", "result2"]);
}
```

### 2. Getting Current State

Get the current state for inspection:

```ts
const state = taskMachine.getState();
console.log(state.key);  // Current state key

// Use type guards
if (state.is("Success")) {
  console.log(state.data.results);  // Type-safe access to results
}
```

### 3. Pattern Matching

Use pattern matching for exhaustive state handling:

```ts
const ui = taskMachine.getState().match({
  Idle: () => "Enter a search term",
  Loading: ({ query }) => `Searching for "${query}"...`,
  Success: ({ query, results }) => 
    `Found ${results.length} results for "${query}": ${results.join(", ")}`,
  Error: ({ query, message }) => 
    `Error searching for "${query}": ${message}`
});
```

## Advanced Pattern: Preserving State Data

Transitions often need to preserve data from the previous state. There are multiple ways to do this:

### 1. Using String Transitions (Auto Preservation)

```ts
// When data types are compatible, data is automatically preserved
{
  Playing: {
    pause: "Paused"  // trackId is preserved from Playing to Paused
  }
}
```

### 2. Using State Access in Function Transitions

```ts
{
  Error: {
    retry: (state) => {
      // Access previous state data
      return "Loading";  // Original query is preserved
    }
  }
}
```

### 3. Using State Factory for Complete Control

```ts
{
  Loading: {
    success: (results: string[]) => (state) => {
      // Use state factory with data from current state
      return TaskStates.Success(state.data.query, results);
    }
  }
}
```

## Example: Todo List Machine

Here's a complete example of a todo list machine:

```ts
import { matchina } from "matchina";

const todoMachine = matchina(
  // States
  {
    Empty: () => ({}),
    Active: (todos: string[]) => ({ todos }),
    Saving: (todos: string[]) => ({ todos }),
    Error: (message: string, todos?: string[]) => ({ message, todos })
  },
  // Transitions
  {
    Empty: {
      add: (todo: string) => "Active"
    },
    Active: {
      add: (todo: string, state) => ({
        ...state,
        data: { todos: [...state.data.todos, todo] }
      }),
      remove: (index: number, state) => {
        const newTodos = [...state.data.todos];
        newTodos.splice(index, 1);
        return newTodos.length === 0 
          ? "Empty" 
          : { ...state, data: { todos: newTodos } };
      },
      save: "Saving"
    },
    Saving: {
      success: "Active",
      error: (message: string) => "Error"
    },
    Error: {
      dismiss: (state) => 
        state.data.todos?.length 
          ? { key: "Active", data: { todos: state.data.todos } } 
          : "Empty"
    }
  },
  "Empty"
);

// Usage
todoMachine.add("Learn Matchina");
todoMachine.add("Build a state machine");
todoMachine.save();

// Simulate API error
setTimeout(() => {
  todoMachine.error("Failed to save todos");
}, 1000);
```

<MachineDemo />

## Next Steps

Now that you understand Factory Machines, explore these related guides:

- [Lifecycle & Hooks](./lifecycle/) - Add hooks for intercepting state changes
- [Effects](./effects/) - Manage side effects with the effects system
- [Promise Machines](./promises/) - Handle async operations with state machines
- [React Integration](./integrations/) - Use state machines with React
