---
title: Factory Machines
description: Create complete state machines with TypeScript inference and type-safe transitions
---

import { Tabs, TabItem } from '@astrojs/starlight/components';
import MachineDemo from "@components/MachineDemo.astro";

## What are Factory Machines?

Factory Machines combine state factories with transitions to create complete state machines with type-safe operations. They extend the Matchbox pattern to provide:

1. **Type-safe state creation** with proper parameter inference
2. **Type-safe transitions** with smart parameter types
3. **State data preservation** when transitioning between states
4. **Lifecycle hooks** for intercepting and reacting to state changes

```ts 
  const {(getState, send)} = fsm(states, transitions, initialState) 
```

## Creating Factory Machines

To create a factory machine, you always start by defining your states using `defineStates`:

```ts
const TaskStates = defineStates({
  Idle: () => ({}),
  Loading: (query: string) => ({ query }),
  Success: (query: string, results: string[]) => ({ query, results }),
  Error: (query: string, message: string) => ({ query, message })
});
```

You can then create a machine with:

```ts
const machine = createMachine(TaskStates, transitions, TaskStates.Idle());
```

You control the machine by calling:

```ts
machine.send(type, ...params);
```

If you want a convenience API (e.g. ergonomic methods for each event), you can:
- Enhance the machine with `zen(machine)`
- Or use `matchina(states, transitions, init)`, which wraps the machine and provides a convenient API

---

## Transition Types & Data Propagation

Transition logic determines:
- Which exit states are possible for each entry state and event
- What parameters are required to send those events
- How state data is propagated or explicitly created during transitions

A transition handler can take one of these forms:

1. **String state key**: If your transition does not accept parameters, simply return the destination state key as a string. Data is preserved automatically if compatible.
   ```ts
   search: "Loading"
   ```
2. **Function with parameters**: If your transition accepts parameters, return a state instance or a function that creates a state instance based on the event.
   - Return a state instance directly:
     ```ts
     search: (query: string) => TaskStates.Loading(query)
     ```
   - Or, for advanced cases, return a function that receives the event object (`{ type, from, to }`) and returns a state instance:
     ```ts
     success: (results: string[]) => (event) => TaskStates.Success(event.from.data.query, results)
     ```

**Summary Table:**

| Form                | Example                                      | Use Case                                 |
|---------------------|----------------------------------------------|------------------------------------------|
| String (state key)  | `pause: "Paused"`                            | No params, simple state change           |
| Function            | `search: (q) => TaskStates.Loading(q)`       | Accepts params, returns state instance   |
| Event function      | `success: (r) => (ev) => ...`                | Needs event context for state creation   |

---

## Using Factory Machines

When using a factory machine directly (without API wrappers), trigger transitions by calling:

```ts
machine.send(type, ...params)
```

- `type` is the event name (string)
- `...params` are the parameters for the transition (if any)

> If you use `zen`, `matchina`, or similar wrappers, you get ergonomic methods for triggering transitions (e.g. `machine.search(query)`).

### Getting Current State

Get the current state for inspection:

```ts
const state = machine.getState();
console.log(state.key);  // Current state key
```

---

## Pattern Matching

Pattern matching on state is only available if your state factory supports it (e.g. if you used a matchbox factory). For more, see the [matchbox documentation](./matchbox/).

---

## Note on matchina

`matchina` is a higher-level API that combines state factories and transitions into a single call, and provides ergonomic transition methods. This page focuses on the lower-level factory machine pattern, but you can use `matchina` for a more streamlined experience.

## Next Steps

Now that you understand Factory Machines, explore these related guides:

- [Lifecycle & Hooks](./lifecycle/) - Add hooks for intercepting state changes
- [Effects](./effects/) - Manage side effects with the effects system
- [Promise Machines](./promises/) - Handle async operations with state machines
- [React Integration](./integrations/) - Use state machines with React
