---
title: Factory Machines
description: Create complete state machines with TypeScript inference and type-safe transitions
---

import { Tabs, TabItem } from '@astrojs/starlight/components';
import MachineDemo from "@components/MachineDemo.astro";

## What are Factory Machines?

Factory Machines combine state factories with transitions to create complete state machines with type-safe operations. They extend the Matchbox pattern to provide:

1. **Type-safe state creation** with proper parameter inference
2. **Type-safe transitions** with smart parameter types
3. **State data preservation** when transitioning between states
4. **Lifecycle hooks** for intercepting and reacting to state changes

```ts 
  const {(getState, send)} = fsm(states, transitions, initialState) 
```

## Creating Factory Machines

There are two ways to create a factory machine:

<Tabs>
  <TabItem label="Using defineStates">
```ts
import { defineStates, createMachine } from "matchina";

// 1. Define state factory
const TaskStates = defineStates({
  Idle: () => ({}),
  Loading: (query: string) => ({ query }),
  Success: (query: string, results: string[]) => ({ query, results }),
  Error: (query: string, message: string) => ({ query, message })
});

// 2. Create a factory machine with type-safe transitions
const taskMachine = createMachine(
  TaskStates,
  {
    Idle: { 
      // Parameter types are inferred from the destination state
      search: (query: string) => "Loading"
    },
    Loading: {
      // Parameter types are inferred from the destination state
      success: (results: string[]) => (state) => {
        // TypeScript knows state.data has query from Loading state
        return TaskStates.Success(state.data.query, results);
      },
      // Parameter types are inferred from the destination state
      error: (message: string) => (state) => {
        // TypeScript knows state.data has query from Loading state
        return TaskStates.Error(state.data.query, message);
      }
    },
    Success: {
      // Return to idle state
      reset: "Idle",
      // Start a new search
      search: (query: string) => "Loading"
    },
    Error: {
      // Return to idle state
      reset: "Idle",
      // Retry the same query
      retry: (state) => {
        // TypeScript knows state.data has query from Error state
        return TaskStates.Loading(state.data.query);
      }
    }
  },
  // 3. Set initial state
  TaskStates.Idle()
);
```
  </TabItem>
  <TabItem label="Using matchina">
```ts
import { matchina } from "matchina";

// Create a state machine directly with matchina
const taskMachine = matchina(
  // 1. Define states
  {
    Idle: undefined,
    Loading: (query: string) => ({ query }),
    Success: (query: string, results: string[]) => ({ query, results }),
    Error: (query: string, message: string) => ({ query, message })
  },
  // 2. Define transitions
  {
    Idle: { 
      search: (query: string) => "Loading" 
    },
    Loading: {
      success: (results: string[]) => "Success",
      error: (message: string) => "Error"
    },
    Success: {
      reset: "Idle",
      search: (query: string) => "Loading"
    },
    Error: {
      reset: "Idle",
      retry: (state) => "Loading"
    }
  },
  // 3. Set initial state
  "Idle"
);
```
  </TabItem>
</Tabs>

## Transition Types

A transition handler can take one of these forms:

1. **String state key**: If your transition does not accept parameters, simply return the destination state key as a string.
   ```ts
   search: "Loading"
   ```
2. **Function with parameters**: If your transition accepts parameters, return a state instance or a function that creates a state instance based on the event.
   - Return a state instance directly:
     ```ts
     search: (query: string) => TaskStates.Loading(query)
     ```
   - Or, for advanced cases, return a function that receives the event object (`{ type, from, to }`) and returns a state instance:
     ```ts
     success: (results: string[]) => (event) => TaskStates.Success(event.from.data.query, results)
     ```

**Summary Table:**

| Form                | Example                                      | Use Case                                 |
|---------------------|----------------------------------------------|------------------------------------------|
| String (state key)  | `pause: "Paused"`                            | No params, simple state change           |
| Function            | `search: (q) => TaskStates.Loading(q)`       | Accepts params, returns state instance   |
| Event function      | `success: (r) => (ev) => ...`                | Needs event context for state creation   |

## Using Factory Machines

When using a factory machine directly (without API wrappers), trigger transitions by calling:

```ts
machine.send(type, ...params)
```

- `type` is the event name (string)
- `...params` are the parameters for the transition (if any)

> If you use `createApi`, `withApi`, `zen`, or `matchina`, you get ergonomic methods for triggering transitions (e.g. `machine.search(query)`).

### Getting Current State

Get the current state for inspection:

```ts
const state = machine.getState();
console.log(state.key);  // Current state key
```

### Pattern Matching

Pattern matching on state is only guaranteed if your state factory is a matchbox factory.

```ts
const ui = state.match({
  Idle: () => "Enter a search term",
  Loading: ({ query }) => `Searching for "${query}"...`,
  Success: ({ query, results }) => 
    `Found ${results.length} results for "${query}": ${results.join(", ")}`,
  Error: ({ query, message }) => 
    `Error searching for "${query}": ${message}`
});
```

## Data Preservation

When transitioning between states, data is preserved automatically if the data types are compatible. For more control, use a function that receives the event object and returns a new state instance.

## Note on matchina

`matchina` is a higher-level API that combines state factories and transitions into a single call, and provides ergonomic transition methods. This page focuses on the lower-level factory machine pattern, but you can use `matchina` for a more streamlined experience.

## Next Steps

Now that you understand Factory Machines, explore these related guides:

- [Lifecycle & Hooks](./lifecycle/) - Add hooks for intercepting state changes
- [Effects](./effects/) - Manage side effects with the effects system
- [Promise Machines](./promises/) - Handle async operations with state machines
- [React Integration](./integrations/) - Use state machines with React
