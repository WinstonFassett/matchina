---
title: Lifecycle & Hooks
description: Intercept and react to state changes with lifecycle hooks
---

import { LifecycleDemo } from "@components/LifecycleDemo";
import { Tabs, TabItem } from '@astrojs/starlight/components';

## What are Lifecycle Hooks?

Lifecycle hooks allow you to intercept and react to state transitions in your state machines. They provide a powerful way to:

1. **Guard** transitions to prevent invalid state changes
2. **React** to state changes with side effects
3. **Modify** state during transitions
4. **Log** state changes for debugging

## Types of Hooks

Matchina provides several types of hooks:

### 1. Guard Hooks

Guard hooks can prevent transitions from occurring:

```ts
import { matchina, setup, guard } from "matchina";

const counter = matchina(
  {
    Idle: () => ({ count: 0 }),
    Counting: (count: number) => ({ count })
  },
  {
    Idle: { 
      start: "Counting" 
    },
    Counting: {
      increment: (state) => ({
        ...state, 
        data: { count: state.data.count + 1 }
      }),
      reset: "Idle"
    }
  },
  "Idle"
);

// Add a guard to prevent counting above 10
setup(counter)(
  guard(ev => {
    if (ev.type !== "increment") return true;
    if (!ev.from.is("Counting")) return true;
    return ev.from.data.count < 10; // Only allow if count < 10
  })
);
```

### 2. Enter Hooks

Enter hooks run when entering a specific state:

```ts
setup(counter)(
  // Enter hook - log when entering specific states
  enter(ev => {
    console.log(`Entering state: ${ev.to.key}`);
    
    if (ev.to.is("Counting") && ev.to.data.count === 10) {
      console.log("Maximum count reached!");
    }
  })
);
```

### 3. Leave Hooks

Leave hooks run when leaving a specific state:

```ts
setup(counter)(
  // Leave hook - log when leaving states
  leave(ev => {
    console.log(`Leaving state: ${ev.from.key}`);
    
    if (ev.from.is("Counting") && ev.to.is("Idle")) {
      console.log("Counter reset!");
    }
  })
);
```

### 4. Effect Hooks

Effect hooks run after state transitions and can be used for side effects:

```ts
setup(counter)(
  // Effect hook - run side effects after transitions
  effect(ev => {
    if (ev.to.is("Counting") && ev.to.data.count % 5 === 0) {
      console.log(`Milestone: ${ev.to.data.count}`);
    }
  })
);
```

## Combining Hooks with setup

You can combine multiple hooks using the `setup` function:

```ts
setup(counter)(
  guard(ev => { /* guard logic */ }),
  enter(ev => { /* enter logic */ }),
  leave(ev => { /* leave logic */ }),
  effect(ev => { /* effect logic */ })
);
```

## Lifecycle Events

Each hook receives an event object with context about the transition:

```ts
type LifecycleEvent = {
  type: string;      // The transition type (e.g., "increment")
  from: State;       // The state before transition
  to: State;         // The state after transition
  params: any[];     // Parameters passed to the transition
}
```

## Interactive Example

<LifecycleDemo client:visible />

Here's the code behind this example:

```ts
onLifecycle(machine, {
  Idle: {
    on: {
      execute: {
        after: ({ type, from, to }) => {
          console.log(
            "Specific state and event:",
            type, // MUST equal 'execute'
            "from", from.key, // Idle
            "to", to.key, // Pending
          );
        }
      }
    },
    exit: ({ type, from, to }) => {
      console.log(
        "Exit Idle:",
        type, // Any transition FROM idle
        "from", from.key, // Idle
        "to", to.key, // Any destination
      );
    }
  },
  Pending: {
    enter: ({ type, from, to }) => {
      console.log(
        "Enter Pending:",
        type, // Any transition TO Pending
        "from", from.key, // Any source
        "to", to.key, // Pending
      );
    }
  }
});
```

## Advanced Pattern: State Change Subscriptions

For observing state changes without affecting them, you can use `subscribe`:

```ts
// Subscribe to all state changes
const unsubscribe = counter.subscribe(state => {
  console.log(`State changed to: ${state.key}`);
  
  if (state.is("Counting")) {
    console.log(`Current count: ${state.data.count}`);
  }
});

// Later, when no longer needed:
unsubscribe();
```

## Next Steps

Now that you understand lifecycle hooks, explore these related guides:

- [Effects](./effects/) - Learn about the dedicated effects system
- [Factory Machines](./machines/) - Create complete state machines
- [Promise Machines](./promises/) - Handle async operations with state machines
- [React Integration](./integrations/) - Use lifecycle hooks with React
            from.key, // MUST equal and autocomplete to 'Idle'
            "to",
            to.key, // MUST equal and autocomplete to 'Pending'
          );
        },
      },
    },
  },
  "*": {
    on: {
      "*": {
        after: ({ type, from, to }) => {
          console.log(
            "any state with any event:\n",
            type, // any valid event b/c wildcard event
            "from",
            from.key, // any valid state b/c wildcard state
            "to",
            to.key, // any valid exit state (which excludes Idle)
            "with data",
            to.data, // any valid state data b/c wildcard state
          );
        },
      },
      reject: {
        after: ({ type, from, to }) => {
          const { name, stack, message } = to.data; // can only be Error type
          console.log(
            "Any reject event:\n",
            type, // MUST be 'reject'
            "from",
            from.key, // any valid state b/c wildcard state
            "with data",
            from.data, // any valid state data b/c wildcard state
            "to",
            to.key, // MUST equal and autocomplete to 'Rejected'
            "Error",
            name,
            message,
            stack, // Error properties
          );
        },
      },
    },
  },
});
```
