---
title: Promise Machines
description: Handle asynchronous operations with type-safe promise state machines
---

import CodeBlock from "@components/CodeBlock.astro";
import code from "@code/examples/usage-promise-machine-hooks.ts?raw";
import { Tabs, TabItem } from '@astrojs/starlight/components';
import PromiseMachineDiagram from "@components/PromiseMachineDiagram.astro";

## What are Promise Machines?

Promise Machines provide a type-safe way to manage asynchronous operations with state machines. They automatically track the lifecycle of promises, handling success and error cases with appropriate typing.

<PromiseMachineDiagram />

## Promise Machine States

Promise machines have four built-in states:

1. **Idle** - The initial state before the promise is executed
2. **Pending** - The promise is in flight (contains `promise` and `params`)
3. **Resolved** - The promise completed successfully (contains `result`)
4. **Rejected** - The promise failed (contains `error`)

## Creating a Promise Machine

Create a promise machine by wrapping any async function:

```ts
import { createPromiseMachine } from "matchina";

// Create a promise machine for data fetching
const fetcher = createPromiseMachine(
  async (url: string, options?: RequestInit) => {
    const response = await fetch(url, options);
    if (!response.ok) {
      throw new Error(`Failed with status ${response.status}`);
    }
    return response.json();
  }
);
```

## Using Promise Machines

### 1. Executing the Promise

Call the `execute` method with the proper parameters:

```ts
// Execute with type-safe parameters
const promise = fetcher.execute("/api/users", { method: "GET" });

// The returned promise resolves to the result or rejects with the error
try {
  const result = await promise;
  console.log("Data fetched:", result);
} catch (error) {
  console.error("Fetch failed:", error);
}
```

### 2. Checking State

Access the current state with type-safe properties:

```ts
const state = fetcher.getState();

if (state.is("Pending")) {
  console.log("Loading data with params:", state.data.params);
  // You can await the promise directly
  const result = await state.data.promise;
}

if (state.is("Resolved")) {
  console.log("Data loaded:", state.data);
}

if (state.is("Rejected")) {
  console.error("Error:", state.data.message);
}
```

{/* ### 3. Pattern Matching

Use pattern matching for exhaustive state handling:

```ts
const ui = fetcher.getState().match({
  Idle: () => "Ready to fetch data",
  Pending: ({params}) => `Loading data from ${params[0]}...`,
  Resolved: (data) => `Data loaded: ${JSON.stringify(data)}`,
  Rejected: (error) => `Error: ${error.message}`
});
``` */}

{/* ## Adding Lifecycle Hooks

Promise machines support all standard lifecycle hooks:

```ts
import { 
  createPromiseMachine, 
  setup, 
  effect, 
  guard, 
  enter, 
  leave 
} from "matchina";

// Create a promise machine
const adder = createPromiseMachine(
  (a: number, b: number) => new Promise<number>(
    resolve => setTimeout(() => resolve(a + b), 500)
  )
);

// Add lifecycle hooks
setup(adder)(
  // Guard to validate parameters
  guard(ev => {
    if (ev.type !== "executing") return true;
    const [a, b] = ev.params[1];
    return a >= 0 && b >= 0; // Only allow non-negative numbers
  }),
  
  // Log when entering pending state
  enter(ev => {
    if (ev.to.is("Pending")) {
      console.log("Started calculation:", ev.to.data.params);
    }
  }),
  
  // Log when leaving pending state
  leave(ev => {
    if (ev.from.is("Pending")) {
      console.log("Leaving pending state");
    }
  }),
  
  // Log when promise resolves
  effect(ev => {
    if (ev.type === "resolve") {
      console.log("Promise resolved with:", ev.to.data);
    }
  })
);
``` */}

{/* ## Complete Example

Here's a complete example with hooks and error handling:

<CodeBlock lang={"js"} code={code} /> */}
{/* 
## Real-world Data Fetching Example

Here's a more practical example of a type-safe data fetching machine:

```ts
import { createPromiseMachine, setup, effect } from "matchina";

// Define User type
type User = {
  id: string;
  name: string;
  email: string;
};

// Create a typed fetcher
const userFetcher = createPromiseMachine(
  async (userId: string): Promise<User> => {
    const response = await fetch(`/api/users/${userId}`);
    if (!response.ok) {
      throw new Error(`Failed to fetch user: ${response.statusText}`);
    }
    return response.json();
  }
);

// Add hooks
setup(userFetcher)(
  // Cache user data
  effect(ev => {
    if (ev.type === "resolve") {
      // TypeScript knows ev.to.data is User
      localStorage.setItem(`user-${ev.to.data.id}`, JSON.stringify(ev.to.data));
    }
  })
);

// Usage in a React component
function UserProfile({ userId }: { userId: string }) {
  const [state, setState] = useState(userFetcher.getState());
  
  useEffect(() => {
    // Subscribe to state changes
    const unsubscribe = userFetcher.subscribe(setState);
    
    // Load user if not already loading or loaded
    if (state.is("Idle")) {
      userFetcher.execute(userId);
    }
    
    return unsubscribe;
  }, [userId]);
  
  // Render based on state
  return state.match({
    Idle: () => <div>Ready to load user</div>,
    Pending: () => <div>Loading user...</div>,
    Resolved: (user) => (
      <div>
        <h1>{user.name}</h1>
        <p>Email: {user.email}</p>
      </div>
    ),
    Rejected: (error) => <div>Error: {error.message}</div>
  });
}
``` */}

## Next Steps

Now that you understand Promise Machines, explore these related guides:

- [Lifecycle & Hooks](./lifecycle/) - Add more advanced hooks for state changes
- [Factory Machines](./machines/) - Create regular state machines
- [React Integration](./integrations/) - Use promise machines in React
