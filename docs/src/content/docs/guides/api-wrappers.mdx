---
title: API Wrappers
description: Learn about the different API wrappers for state machines in Matchina
---

import { Tabs, TabItem } from '@astrojs/starlight/components';

# API Wrappers

Matchina provides several API wrappers that enhance the usability of state machines while simplifying their interfaces for different use cases. These wrappers include:

- **createApi**: Creates a flat event API for a factory machine
- **zen**: Combines the event API with state and change access
- **pure**: Provides a minimal state machine interface with only the essential methods

## createApi

The `createApi` function creates a flat event API for a factory machine, simplifying the process of sending events to a machine. This is particularly useful when you want to expose a cleaner interface for transitions without exposing the full machine.

```ts twoslash
// @noErrors
import { createMachine } from 'matchina';
import { createApi } from 'matchina';

const toggleMachine = createMachine({
  initial: 'off',
  states: {
    off: {
      on: { TOGGLE: 'on' }
    },
    on: {
      on: { TOGGLE: 'off' }
    }
  }
});

// Create a flat event API
const toggleApi = createApi(toggleMachine);

// Now you can simply call the event methods
toggleApi.TOGGLE();
```

The generated API is fully typed, with the correct parameter types for each event handler:

```ts twoslash
// @noErrors
import { createMachine } from 'matchina';
import { createApi } from 'matchina';

const counterMachine = createMachine({
  initial: 'idle',
  context: { count: 0 },
  states: {
    idle: {
      on: { 
        INCREMENT: {
          target: 'idle',
          action: (ctx, params: [number]) => {
            ctx.count += params[0];
          }
        },
        DECREMENT: {
          target: 'idle',
          action: (ctx, params: [number]) => {
            ctx.count -= params[0];
          }
        }
      }
    }
  }
});

const api = createApi(counterMachine);

// TypeScript knows these need a number parameter
api.INCREMENT(1);
api.DECREMENT(2);
```

You can also use the `withApi` helper to add the API directly to your machine:

```ts twoslash
// @noErrors
import { createMachine } from 'matchina';
import { withApi } from 'matchina';

const toggleMachine = createMachine({
  initial: 'off',
  states: {
    off: {
      on: { TOGGLE: 'on' }
    },
    on: {
      on: { TOGGLE: 'off' }
    }
  }
});

// Enhance the machine with an API
const enhancedMachine = withApi(toggleMachine);

// Now you can use the machine with its API
enhancedMachine.api.TOGGLE();
```

## zen

The `zen` wrapper builds on top of `createApi` and provides a clean, minimal interface for working with state machines. It combines the event API with easy access to the machine's state and change, along with a setup method for integrations.

```ts twoslash
// @noErrors
import { createMachine } from 'matchina';
import { zen } from 'matchina/extras';

const toggleMachine = createMachine({
  initial: 'off',
  states: {
    off: {
      on: { TOGGLE: 'on' }
    },
    on: {
      on: { TOGGLE: 'off' }
    }
  }
});

// Create a zen wrapper
const toggle = zen(toggleMachine);

// Send events using the flat API
toggle.TOGGLE();

// Access the current state
console.log(toggle.state); // 'off' or 'on'

// Access the last state change
console.log(toggle.change); // { from: 'off', to: 'on' } or similar

// Access the underlying machine if needed
const machine = toggle.machine;
```

The `zen` wrapper is ideal for React components and other scenarios where you want a simple, unified interface.

## pure

The `pure` wrapper provides the most minimal interface for a state machine, exposing only the essential `getState` and `send` methods. This is useful when you want to limit access to the machine's functionality or when you're passing the machine to code that only needs these core capabilities.

```ts twoslash
// @noErrors
import { createMachine } from 'matchina';
import { pure } from 'matchina';

const toggleMachine = createMachine({
  initial: 'off',
  states: {
    off: {
      on: { TOGGLE: 'on' }
    },
    on: {
      on: { TOGGLE: 'off' }
    }
  }
});

// Create a pure state machine interface
const pureMachine = pure(toggleMachine);

// Only getState and send are available
console.log(pureMachine.getState()); // 'off'
pureMachine.send('TOGGLE'); // transitions to 'on'
console.log(pureMachine.getState()); // 'on'
```

## When to Use Each Wrapper

<Tabs>
  <TabItem label="createApi">
    Use `createApi` when:
    - You want to expose a simplified event-sending interface
    - You're building a public API for your state machine
    - You want fully typed event handlers with proper parameter types
  </TabItem>

  <TabItem label="zen">
    Use `zen` when:
    - You need both event methods and state access in a clean package
    - You're using the machine within a component or module
    - You want to easily integrate with frameworks like React
    - You appreciate a more functional, fluent interface
  </TabItem>

  <TabItem label="pure">
    Use `pure` when:
    - You want to enforce a minimal interface
    - You're passing the machine to code that should only read state and send events
    - You're implementing the dependency inversion principle
    - You want to hide implementation details
  </TabItem>
</Tabs>

## Example: Combining Wrappers

You can combine wrappers for different scenarios. Here's an example of using `createApi` internally and exposing a `pure` interface externally:

```ts twoslash
// @noErrors
import { createMachine } from 'matchina';
import { createApi, pure } from 'matchina';

// Create a complex machine
const authMachine = createMachine({
  initial: 'signedOut',
  context: { username: '', error: null },
  states: {
    signedOut: {
      on: { 
        LOGIN: {
          target: 'authenticating',
          action: (ctx, [username, password]) => {
            ctx.username = username;
          }
        }
      }
    },
    authenticating: {
      on: { 
        SUCCESS: 'signedIn',
        FAILURE: {
          target: 'signedOut',
          action: (ctx, [error]) => {
            ctx.error = error;
          }
        }
      }
    },
    signedIn: {
      on: { LOGOUT: 'signedOut' }
    }
  }
});

// For internal use, create a typed API
const api = createApi(authMachine);

// For external consumers, provide only the pure interface
const publicMachine = pure(authMachine);

// Internal usage
function authenticateUser(username, password) {
  api.LOGIN(username, password);
  // Simulate auth process
  setTimeout(() => {
    if (username === 'admin' && password === 'password') {
      api.SUCCESS();
    } else {
      api.FAILURE(new Error('Invalid credentials'));
    }
  }, 1000);
}

// External API only exposes the pure machine
export { publicMachine, authenticateUser };
```

In this example:
- Internal code uses the `createApi` wrapper for typed event methods
- External code only receives the `pure` interface with limited capabilities
- The authentication logic is encapsulated, with only necessary parts exposed
