---
title: React Composition
description: React composition patterns with machines
---

import { Tabs, TabItem } from "@astrojs/starlight/components";
import { SimpleComposer } from "@code/examples/message-composer/components/SimpleComposer";
import { EditMessageDemo } from "@code/examples/message-composer/components/EditMessageDemo";
import { ChannelComposer } from "@code/examples/message-composer/components/ChannelComposer";
import { ThreadComposerDemo } from "@code/examples/message-composer/components/ThreadComposerDemo";
import ThreadComposerCode from "@code/examples/message-composer/components/ThreadComposer.tsx?raw";
import { ForwardMessageDemo } from "@code/examples/message-composer/components/ForwardMessageDemo";
import { Code } from "@astrojs/starlight/components";
import SimpleComposerCode from "@code/examples/message-composer/components/SimpleComposer.tsx?raw";
import EditMessageComposerCode from "@code/examples/message-composer/components/EditMessageComposer.tsx?raw";
import ForwardComposerCode from "@code/examples/message-composer/components/ForwardComposer.tsx?raw";
import ChannelComposerCode from "@code/examples/message-composer/components/ChannelComposer.tsx?raw";

## Single Component Pattern

<Tabs>
  <TabItem label="Basic">
    <div class="not-content">
      <SimpleComposer
        client:only="react"
        title="Send Message"
        showDropZone={false}
        showEmojiButton={false}
        showClearButton={false}
      />
    </div>
    <Code code={`<SimpleComposer
        client:only="react"
        title="Send Message"
        showDropZone={false}
        showEmojiButton={false}
        showClearButton={false}
      />`} lang="tsx" title="BasicComposer.tsx" />
    <Code code={SimpleComposerCode} lang="tsx" title="SimpleComposer.tsx" />
  </TabItem>
  <TabItem label="Full Featured">
    <div class="not-content">
      <SimpleComposer
        client:only="react"
        title="New Message"
        showDropZone={true}
        showEmojiButton={true}
        showClearButton={true}
      />
    </div>
    <Code code={`<SimpleComposer
        client:only="react"
        title="New Message"
        showDropZone={true}
        showEmojiButton={true}
        showClearButton={true}
      />`} lang="tsx" title="FullComposer.tsx" />
    <Code code={SimpleComposerCode} lang="tsx" title="SimpleComposer.tsx" />
  </TabItem>
  <TabItem label="Edit Mode (Simple)">
    <div class="not-content">
      <SimpleComposer
        client:only="react"
        title="Edit Message"
        showDropZone={false}
        showEmojiButton={true}
        showClearButton={true}
        isEditMode={true}
        initialMessage="This is the original message that needs editing"
      />
    </div>
    <Code code={`<SimpleComposer
        client:only="react"
        title="Edit Message"
        showDropZone={false}
        showEmojiButton={true}
        showClearButton={true}
        isEditMode={true}
        initialMessage="This is the original message that needs editing"
      />`} lang="tsx" title="EditComposer.tsx" />
    <Code code={SimpleComposerCode} lang="tsx" title="SimpleComposer.tsx" />
  </TabItem>
  
</Tabs>



## Multiple Component Pattern

When your application grows, you might want to split your UI into multiple components. You can still use the `useMachine` hook in each component, but you need to ensure that they share the same machine instance.

<Tabs>
  <TabItem label="Channel Composer (Canonical)">
    <div class="not-content">
      <ChannelComposer
        client:only="react"
        channelId="general"
      />
    </div>
    <Code code={ChannelComposerCode} lang="tsx" title="ChannelComposer.tsx" />
  </TabItem>
  <TabItem label="Thread Composer (Thread Reply)">
    <div class="not-content">
      <ThreadComposerDemo client:only="react" />
    </div>
    <Code code={ThreadComposerCode} lang="tsx" title="ThreadComposer.tsx" />
  </TabItem>
  <TabItem label="Edit Message Composer (Dialog Pattern)">
    <div class="not-content">
      <EditMessageDemo client:only="react" />
    </div>
    <Code code={EditMessageComposerCode} lang="tsx" title="EditMessageComposer.tsx" />
  </TabItem>
  <TabItem label="Forward Message Composer (Dialog Pattern)">
    <div class="not-content">
      <ForwardMessageDemo client:only="react" />
    </div>
    {/* Add code sample for ForwardComposer if/when available */}
    <Code code={ForwardComposerCode} lang="tsx" title="ForwardComposer.tsx" />
  </TabItem>
</Tabs>

---

Fernando Rojas has a great React talk called Composition is All You Need.

Demo Notes / pattern :

* `ForwardMachineContext`, `ForwardMachineProvider`, `useForwardMachine` are all **generated by the lib**.
* `machine` stays pure (no React refs), `meta` or UI refs live in the UI layer if needed.
* `extendActions` allows **nested overrides or logging**.
* `useForwardMachine()` returns `[state, actions, machine]` (hook is simple and ergonomic).


Key Points 

* **Machine** is fully pure — no React dependencies.
* **Provider** exposes `[state, actions, machine, meta]`.
* **UI** can use `meta` for refs or shared static values if needed.
* **Actions can be extended** in a subtree without affecting outer providers.
* Default `selectState` maps `change.to` → minimal re-renders and ergonomic hook usage.



### 1. **Machine layer**

* Pure logic, immutable state via Immer, no React dependencies.
* Fully reusable outside React if needed.

### 2. **Provider / Context / Hook layer**

* Generated by **lib code** (`createReactMachineModule`) → minimal boilerplate.
* Handles `useMachine`, `extendActions`, `selectState`.
* Returns `[state, actions, machine]` — intuitive, familiar tuple.
* Supports **nested providers with action overrides** without touching outer machines.

### 3. **UI layer**

* Local React refs or static UI stuff live here.
* Can optionally lift shared refs via small UI-specific context if multiple components need the same ref.
* Clean separation of concerns: machine logic ≠ context wiring ≠ UI specifics.

### 4. **Ergonomics / DX**

* Simple `useForwardMachine()` hook for most use cases.
* Optional `extendActions` and `selectState` for custom behavior.
* TypeScript types flow through all layers (`state` + `actions` strongly typed).
* Fully composable and nestable — supports logging, testing, feature flags, scoped overrides.

### 5. **Minimal, expressive, and future-proof**

* Only three things in context: `state`, `actions`, `machine`. Optional `meta` in UI if needed.
* Hook + Provider is all a developer needs to use the machine in a subtree.
* Default `selectState` maps `change.to` → simple re-render logic.

***

**Verdict:**

* ✅ Ergonomic for developers
* ✅ Fully type-safe
* ✅ Supports advanced composition
* ✅ Machines remain pure and reusable
* ✅ Clean separation of concerns

