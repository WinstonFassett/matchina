---
title: Stopwatch with React State and Lifecycle Hooks
---

import StopwatchExample from "@code/examples/stopwatch-using-react-state-using-lifecycle-instead-of-useEffect/example";
import machineCode from "@code/examples/stopwatch-using-react-state-using-lifecycle-instead-of-useEffect/machine.ts?raw";
import hookCode from "@code/examples/stopwatch-using-react-state-using-lifecycle-instead-of-useEffect/useStopwatch.ts?raw";
import indexCode from "@code/examples/stopwatch-using-react-state-using-lifecycle-instead-of-useEffect/index.tsx?raw";
import viewCode from "@code/examples/stopwatch-using-react-state-using-lifecycle-instead-of-useEffect/StopwatchView.tsx?raw";
import CodeBlock from "@components/CodeBlock.astro";
import CodeTabs from "@components/CodeTabs.astro";

## Interactive Stopwatch Example

<div className="not-content">
  <StopwatchExample client:only="react" />
</div>

## About This Example

This version demonstrates using `onLifecycle` hooks instead of `useEffect`:

- Uses lifecycle events to manage side effects
- Provides better TypeScript autocompletion support
- Constrains event types to their specific states

While slightly more verbose than other approaches, `onLifecycle` offers a superior developer experience with:

1. Strong type inference for state and event-specific data
2. Automatic documentation through IDE autocomplete
3. Clear separation of lifecycle events by state

For example, in a configuration like `{ Rejected: { enter: ev => { ev.data.error } } }`, TypeScript would correctly infer and autocomplete `ev.error` since it's part of the `Rejected` state's `data`.

## Machine Code

<CodeTabs
  files={[
    { name: "machine.ts", code: machineCode },
    { name: "useStopwatch.ts", code: hookCode },
    { name: "StopwatchView.tsx", code: viewCode },
    { name: "index.tsx", code: indexCode },
  ]}
/>
