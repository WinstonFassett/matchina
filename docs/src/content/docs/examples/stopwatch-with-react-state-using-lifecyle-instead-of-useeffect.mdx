---
title: Stopwatch with React state and useLifecycle
---

import { Stopwatch } from "@code/examples/Stopwatch-with-React-state-using-lifecycle-instead-of-useEffect.tsx";
import code from "@code/examples/Stopwatch-with-React-state-using-lifecycle-instead-of-useEffect.tsx?raw";
import CodeBlock from "@components/CodeBlock.astro";

<div className="text-4xl text-red-500 text-green-500 text-yellow-500 w-full"></div>

<div className="not-content">
  <Stopwatch client:visible />
</div>

This version uses `onLifecycle` instead of `useEffect`.

It is somewhat verbose, and mainly serves to show how the `onLifecycle` hook _could_ be used here.

One nice thing about `onLifecycle` is the autocomplete experience for the developer that makes it easy to explore the available extensions for each state and event.

And within a given state or event config, the event will be constrained to that state and/or event. For example `{ Rejected: { enter: ev => { ev.data.error } } }` would autocomplete `ev.error` that is part of the `Rejected` state `data`.

## Full Code

<CodeBlock lang="jsx" code={code} />
