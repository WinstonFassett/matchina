---
title: Checkout Flow with Multiple Machines
description: Building a checkout flow using coordinated state machines
---

import { Tabs, TabItem } from '@astrojs/starlight/components';

## Introduction

This example demonstrates how to build a checkout flow using multiple coordinated state machines. 
We'll create an authentication machine and a checkout flow machine that work together to create a
complete e-commerce checkout experience.

## The Challenge

Building a checkout flow presents several challenges:

- Managing user authentication state
- Handling multi-step checkout processes
- Coordinating between different concerns (auth, shipping, payment)
- Preventing invalid state transitions (e.g., can't proceed to payment without authentication)
- Managing asynchronous operations (user login, payment processing)

Using multiple coordinated state machines allows us to separate these concerns while ensuring they
work together correctly.

## Building the Authentication Machine

First, let's create our authentication machine to handle user login and registration:

```ts
import { matchbox, matchina } from "matchina";

// Define auth states
const authStates = matchbox({
  Anonymous: () => ({}),
  
  Authenticating: (
    credentials: { email: string; password: string }
  ) => ({
    credentials
  }),
  
  Authenticated: (
    user: {
      id: string;
      email: string;
      name: string;
    }
  ) => ({
    user
  }),
  
  AuthenticationFailed: (
    error: string,
    credentials: { email: string; password: string }
  ) => ({
    error,
    credentials
  }),
  
  RegistrationInProgress: (
    details: {
      name: string;
      email: string;
      password: string;
    }
  ) => ({
    details
  }),
  
  RegistrationFailed: (
    error: string,
    details: {
      name: string;
      email: string;
      password: string;
    }
  ) => ({
    error,
    details
  })
});

// Create the auth machine
const createAuthMachine = () => {
  return matchina(
    authStates,
    {
      Anonymous: {
        // Start the login process
        login: (credentials: { email: string; password: string }) => ({
          key: "Authenticating",
          data: credentials
        }),
        
        // Start the registration process
        register: (details: { name: string; email: string; password: string }) => ({
          key: "RegistrationInProgress",
          data: details
        })
      },
      
      Authenticating: {
        // Authentication succeeded
        success: (user: { id: string; email: string; name: string }) => ({
          key: "Authenticated",
          data: user
        }),
        
        // Authentication failed
        failure: (error: string, state) => ({
          key: "AuthenticationFailed",
          data: {
            error,
            credentials: state.data.credentials
          }
        })
      },
      
      Authenticated: {
        // Log out
        logout: () => ({
          key: "Anonymous",
          data: {}
        }),
        
        // Update user profile
        updateProfile: (user: { id: string; email: string; name: string }) => ({
          key: "Authenticated",
          data: user
        })
      },
      
      AuthenticationFailed: {
        // Try again
        retry: (state) => ({
          key: "Authenticating",
          data: state.data.credentials
        }),
        
        // Go back to anonymous
        cancel: () => ({
          key: "Anonymous",
          data: {}
        })
      },
      
      RegistrationInProgress: {
        // Registration succeeded
        success: (user: { id: string; email: string; name: string }) => ({
          key: "Authenticated",
          data: user
        }),
        
        // Registration failed
        failure: (error: string, state) => ({
          key: "RegistrationFailed",
          data: {
            error,
            details: state.data.details
          }
        })
      },
      
      RegistrationFailed: {
        // Try again
        retry: (state) => ({
          key: "RegistrationInProgress",
          data: state.data.details
        }),
        
        // Go back to anonymous
        cancel: () => ({
          key: "Anonymous",
          data: {}
        })
      }
    },
    "Anonymous" // Initial state
  );
};
```

## Building the Checkout Machine

Now, let's create a checkout machine that handles the steps of the checkout process:

```ts
// Define checkout states
const checkoutStates = matchbox({
  Cart: (
    items: Array<{
      id: string;
      name: string;
      price: number;
      quantity: number;
    }>,
    total: number
  ) => ({
    items,
    total
  }),
  
  ShippingInfo: (
    items: Array<{
      id: string;
      name: string;
      price: number;
      quantity: number;
    }>,
    total: number,
    shippingInfo?: {
      address: string;
      city: string;
      state: string;
      zip: string;
      country: string;
    }
  ) => ({
    items,
    total,
    shippingInfo
  }),
  
  PaymentInfo: (
    items: Array<{
      id: string;
      name: string;
      price: number;
      quantity: number;
    }>,
    total: number,
    shippingInfo: {
      address: string;
      city: string;
      state: string;
      zip: string;
      country: string;
    },
    paymentInfo?: {
      cardNumber: string;
      expiryDate: string;
      cvv: string;
      name: string;
    }
  ) => ({
    items,
    total,
    shippingInfo,
    paymentInfo
  }),
  
  Processing: (
    items: Array<{
      id: string;
      name: string;
      price: number;
      quantity: number;
    }>,
    total: number,
    shippingInfo: {
      address: string;
      city: string;
      state: string;
      zip: string;
      country: string;
    },
    paymentInfo: {
      cardNumber: string;
      expiryDate: string;
      cvv: string;
      name: string;
    }
  ) => ({
    items,
    total,
    shippingInfo,
    paymentInfo
  }),
  
  Confirmed: (
    items: Array<{
      id: string;
      name: string;
      price: number;
      quantity: number;
    }>,
    total: number,
    shippingInfo: {
      address: string;
      city: string;
      state: string;
      zip: string;
      country: string;
    },
    paymentInfo: {
      cardNumber: string;
      expiryDate: string;
      cvv: string;
      name: string;
    },
    orderId: string
  ) => ({
    items,
    total,
    shippingInfo,
    paymentInfo,
    orderId
  }),
  
  Failed: (
    items: Array<{
      id: string;
      name: string;
      price: number;
      quantity: number;
    }>,
    total: number,
    error: string
  ) => ({
    items,
    total,
    error
  })
});

// Create the checkout machine
const createCheckoutMachine = () => {
  return matchina(
    checkoutStates,
    {
      Cart: {
        // Update cart items
        updateItems: (
          items: Array<{
            id: string;
            name: string;
            price: number;
            quantity: number;
          }>,
          state
        ) => {
          const total = items.reduce((sum, item) => sum + (item.price * item.quantity), 0);
          return {
            key: "Cart",
            data: {
              items,
              total
            }
          };
        },
        
        // Proceed to shipping (requires authentication)
        proceedToShipping: (
          authMachine: ReturnType<typeof createAuthMachine>,
          state
        ) => {
          // Check if user is authenticated
          if (!authMachine.state.is("Authenticated")) {
            return {
              key: "Failed",
              data: {
                items: state.data.items,
                total: state.data.total,
                error: "Authentication required to proceed"
              }
            };
          }
          
          return {
            key: "ShippingInfo",
            data: {
              items: state.data.items,
              total: state.data.total
            }
          };
        }
      },
      
      ShippingInfo: {
        // Save shipping information
        saveShippingInfo: (
          shippingInfo: {
            address: string;
            city: string;
            state: string;
            zip: string;
            country: string;
          },
          state
        ) => ({
          key: "ShippingInfo",
          data: {
            ...state.data,
            shippingInfo
          }
        }),
        
        // Go back to cart
        backToCart: (state) => ({
          key: "Cart",
          data: {
            items: state.data.items,
            total: state.data.total
          }
        }),
        
        // Proceed to payment
        proceedToPayment: (state) => {
          // Ensure shipping info is complete
          if (!state.data.shippingInfo) {
            return {
              key: "Failed",
              data: {
                items: state.data.items,
                total: state.data.total,
                error: "Shipping information is required"
              }
            };
          }
          
          return {
            key: "PaymentInfo",
            data: {
              items: state.data.items,
              total: state.data.total,
              shippingInfo: state.data.shippingInfo
            }
          };
        }
      },
      
      PaymentInfo: {
        // Save payment information
        savePaymentInfo: (
          paymentInfo: {
            cardNumber: string;
            expiryDate: string;
            cvv: string;
            name: string;
          },
          state
        ) => ({
          key: "PaymentInfo",
          data: {
            ...state.data,
            paymentInfo
          }
        }),
        
        // Go back to shipping
        backToShipping: (state) => ({
          key: "ShippingInfo",
          data: {
            items: state.data.items,
            total: state.data.total,
            shippingInfo: state.data.shippingInfo
          }
        }),
        
        // Place order
        placeOrder: (state) => {
          // Ensure payment info is complete
          if (!state.data.paymentInfo) {
            return {
              key: "Failed",
              data: {
                items: state.data.items,
                total: state.data.total,
                error: "Payment information is required"
              }
            };
          }
          
          return {
            key: "Processing",
            data: {
              items: state.data.items,
              total: state.data.total,
              shippingInfo: state.data.shippingInfo,
              paymentInfo: state.data.paymentInfo
            }
          };
        }
      },
      
      Processing: {
        // Order confirmation
        confirmOrder: (orderId: string, state) => ({
          key: "Confirmed",
          data: {
            items: state.data.items,
            total: state.data.total,
            shippingInfo: state.data.shippingInfo,
            paymentInfo: state.data.paymentInfo,
            orderId
          }
        }),
        
        // Payment processing failed
        processingFailed: (error: string, state) => ({
          key: "Failed",
          data: {
            items: state.data.items,
            total: state.data.total,
            error
          }
        })
      },
      
      Confirmed: {
        // Start a new order
        newOrder: () => ({
          key: "Cart",
          data: {
            items: [],
            total: 0
          }
        })
      },
      
      Failed: {
        // Try again (go back to cart)
        tryAgain: (state) => ({
          key: "Cart",
          data: {
            items: state.data.items,
            total: state.data.total
          }
        })
      }
    },
    "Cart", // Initial state
    {
      items: [],
      total: 0
    }
  );
};
```

## Coordinating Multiple Machines

Now let's see how these machines work together in a coordinated checkout flow:

```ts
// Create the machines
const authMachine = createAuthMachine();
const checkoutMachine = createCheckoutMachine();

// Example usage: Adding items to cart
checkoutMachine.updateItems([
  { id: "1", name: "Product 1", price: 29.99, quantity: 2 },
  { id: "2", name: "Product 2", price: 49.99, quantity: 1 }
]);

// Try to proceed to shipping without authentication
try {
  checkoutMachine.proceedToShipping(authMachine);
  console.log(checkoutMachine.state.key); // "Failed"
  console.log(checkoutMachine.state.data.error); // "Authentication required to proceed"
} catch (e) {
  console.error("Error:", e);
}

// Authenticate the user
authMachine.login({
  email: "user@example.com",
  password: "password123"
});

// Simulate successful authentication
authMachine.success({
  id: "user-123",
  email: "user@example.com",
  name: "John Doe"
});

console.log(authMachine.state.key); // "Authenticated"

// Now we can proceed to shipping
checkoutMachine.proceedToShipping(authMachine);
console.log(checkoutMachine.state.key); // "ShippingInfo"

// Save shipping information
checkoutMachine.saveShippingInfo({
  address: "123 Main St",
  city: "Anytown",
  state: "CA",
  zip: "12345",
  country: "USA"
});

// Proceed to payment
checkoutMachine.proceedToPayment();
console.log(checkoutMachine.state.key); // "PaymentInfo"

// Save payment information
checkoutMachine.savePaymentInfo({
  cardNumber: "4111 1111 1111 1111",
  expiryDate: "12/25",
  cvv: "123",
  name: "John Doe"
});

// Place the order
checkoutMachine.placeOrder();
console.log(checkoutMachine.state.key); // "Processing"

// Simulate successful order processing
checkoutMachine.confirmOrder("ORDER-123456", checkoutMachine.state.data);
console.log(checkoutMachine.state.key); // "Confirmed"
console.log(checkoutMachine.state.data.orderId); // "ORDER-123456"
```

## React Integration

Here's how to use these coordinated machines in a React application:

```tsx
import React from "react";
import { useMachine } from "matchina/react";

function CheckoutPage() {
  // Create machines
  const [authMachine, setAuthMachine] = React.useState(() => createAuthMachine());
  const [checkoutMachine, setCheckoutMachine] = React.useState(() => createCheckoutMachine());
  
  // Use machines in React
  useMachine(authMachine);
  useMachine(checkoutMachine);
  
  // Handle login
  const handleLogin = async (credentials: { email: string; password: string }) => {
    authMachine.login(credentials);
    
    try {
      // Simulate API call
      const user = await authenticateUser(credentials);
      authMachine.success(user);
    } catch (error) {
      authMachine.failure(error.message);
    }
  };
  
  // Handle checkout
  const handleProceedToShipping = () => {
    checkoutMachine.proceedToShipping(authMachine);
  };
  
  // Render appropriate component based on auth state
  const renderAuthComponent = () => {
    return authMachine.state.match({
      Anonymous: () => <LoginForm onLogin={handleLogin} />,
      Authenticating: () => <div>Authenticating...</div>,
      AuthenticationFailed: (data) => (
        <LoginForm 
          onLogin={handleLogin} 
          error={data.error} 
          initialValues={data.credentials} 
        />
      ),
      Authenticated: (data) => (
        <UserProfile user={data.user} onLogout={() => authMachine.logout()} />
      ),
      RegistrationInProgress: () => <div>Registering...</div>,
      RegistrationFailed: (data) => (
        <RegistrationForm 
          onRegister={(details) => authMachine.register(details)} 
          error={data.error} 
          initialValues={data.details} 
        />
      )
    });
  };
  
  // Render appropriate component based on checkout state
  const renderCheckoutComponent = () => {
    return checkoutMachine.state.match({
      Cart: (data) => (
        <CartView 
          items={data.items} 
          total={data.total}
          onUpdateItems={(items) => checkoutMachine.updateItems(items)}
          onProceedToShipping={handleProceedToShipping}
        />
      ),
      Failed: (data) => (
        <ErrorView 
          error={data.error} 
          onTryAgain={() => checkoutMachine.tryAgain()} 
        />
      ),
      ShippingInfo: (data) => (
        <ShippingForm 
          initialValues={data.shippingInfo}
          onSave={(info) => checkoutMachine.saveShippingInfo(info)}
          onBack={() => checkoutMachine.backToCart()}
          onNext={() => checkoutMachine.proceedToPayment()}
        />
      ),
      PaymentInfo: (data) => (
        <PaymentForm 
          initialValues={data.paymentInfo}
          total={data.total}
          onSave={(info) => checkoutMachine.savePaymentInfo(info)}
          onBack={() => checkoutMachine.backToShipping()}
          onPlaceOrder={() => checkoutMachine.placeOrder()}
        />
      ),
      Processing: () => (
        <div>
          <h2>Processing Order</h2>
          <p>Please wait while we process your payment...</p>
        </div>
      ),
      Confirmed: (data) => (
        <OrderConfirmation 
          orderId={data.orderId}
          items={data.items}
          total={data.total}
          onNewOrder={() => checkoutMachine.newOrder()}
        />
      )
    });
  };
  
  return (
    <div className="checkout-page">
      <div className="auth-section">
        {renderAuthComponent()}
      </div>
      
      <div className="checkout-section">
        <h1>Checkout</h1>
        {renderCheckoutComponent()}
      </div>
    </div>
  );
}

// Simulate API call
function authenticateUser(credentials: { email: string; password: string }) {
  return new Promise((resolve, reject) => {
    setTimeout(() => {
      if (credentials.email === "user@example.com" && credentials.password === "password123") {
        resolve({
          id: "user-123",
          email: "user@example.com",
          name: "John Doe"
        });
      } else {
        reject(new Error("Invalid credentials"));
      }
    }, 1000);
  });
}
```

## Benefits of Coordinated Machines

Using multiple coordinated state machines provides several benefits:

1. **Separation of Concerns**: Each machine focuses on one aspect of the application (auth vs. checkout)
2. **Reusability**: The auth machine can be reused across different parts of the application
3. **Reduced Complexity**: Each machine is simpler than one large combined machine
4. **Better Testability**: Each machine can be tested in isolation
5. **Flexibility**: Machines can be composed in different ways to create complex workflows

## Enhancing with a Payment Machine

For even more separation of concerns, we could extract payment processing into its own machine:

```ts
// Payment machine states
const paymentStates = matchbox({
  Idle: () => ({}),
  
  Processing: (
    amount: number,
    paymentDetails: {
      cardNumber: string;
      expiryDate: string;
      cvv: string;
      name: string;
    }
  ) => ({
    amount,
    paymentDetails
  }),
  
  Successful: (
    amount: number,
    transactionId: string
  ) => ({
    amount,
    transactionId
  }),
  
  Failed: (
    amount: number,
    error: string
  ) => ({
    amount,
    error
  })
});

// Create the payment machine
const createPaymentMachine = () => {
  return matchina(
    paymentStates,
    {
      Idle: {
        // Start payment processing
        processPayment: (
          amount: number,
          paymentDetails: {
            cardNumber: string;
            expiryDate: string;
            cvv: string;
            name: string;
          }
        ) => ({
          key: "Processing",
          data: {
            amount,
            paymentDetails
          }
        })
      },
      
      Processing: {
        // Payment succeeded
        success: (transactionId: string, state) => ({
          key: "Successful",
          data: {
            amount: state.data.amount,
            transactionId
          }
        }),
        
        // Payment failed
        failure: (error: string, state) => ({
          key: "Failed",
          data: {
            amount: state.data.amount,
            error
          }
        })
      },
      
      Successful: {
        // Reset to idle
        reset: () => ({
          key: "Idle",
          data: {}
        })
      },
      
      Failed: {
        // Try again
        retry: (
          paymentDetails: {
            cardNumber: string;
            expiryDate: string;
            cvv: string;
            name: string;
          },
          state
        ) => ({
          key: "Processing",
          data: {
            amount: state.data.amount,
            paymentDetails
          }
        }),
        
        // Reset to idle
        reset: () => ({
          key: "Idle",
          data: {}
        })
      }
    },
    "Idle" // Initial state
  );
};
```

## Putting It All Together

In a real application, we would coordinate all three machines to create a complete checkout flow:

```ts
// Create all machines
const authMachine = createAuthMachine();
const checkoutMachine = createCheckoutMachine();
const paymentMachine = createPaymentMachine();

// When the user places an order in the checkout machine:
checkoutMachine.placeOrder();

// Start payment processing
if (checkoutMachine.state.is("Processing")) {
  const { total, paymentInfo } = checkoutMachine.state.data;
  
  paymentMachine.processPayment(total, paymentInfo);
  
  // Simulate payment processing (in a real app, this would be an API call)
  setTimeout(() => {
    if (Math.random() > 0.2) {
      // Payment succeeded
      const transactionId = "TXN-" + Math.floor(Math.random() * 1000000);
      paymentMachine.success(transactionId);
      
      // Confirm the order in the checkout machine
      checkoutMachine.confirmOrder("ORDER-" + transactionId.substr(4), checkoutMachine.state.data);
    } else {
      // Payment failed
      paymentMachine.failure("Payment processing failed");
      
      // Fail the checkout
      checkoutMachine.processingFailed("Payment processing failed");
    }
  }, 2000);
}
```

## Conclusion

This example demonstrates how to build a complete checkout flow using multiple coordinated state machines. By separating authentication, checkout flow, and payment processing into different machines, we create a more maintainable and flexible system.

Each machine has a single responsibility and can evolve independently, while still working together to create a cohesive user experience. This pattern can be extended to other complex workflows in your applications.
