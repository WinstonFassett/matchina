---
title: Form Validation State Machine
description: Creating a reusable form state machine factory
---

import { Tabs, TabItem } from '@astrojs/starlight/components';

## Introduction

This example demonstrates how to build a reusable form validation state machine factory that can be customized for different form schemas and validation rules. It shows how Matchina can be used to create powerful, type-safe abstractions that are easy to reuse.

## The Challenge with Forms

Forms present several challenges:
- Managing multiple field values
- Tracking which fields have been touched
- Handling field-level and form-level validation
- Managing async validation and submission
- Providing user feedback at the right time

A state machine approach allows us to model these concerns clearly and prevent impossible states.

## Creating a Form Machine Factory

Instead of building a one-off form state machine, let's create a reusable factory that can generate form machines for any schema:

```ts
import { matchbox, matchina } from "matchina";

// Generic form machine factory
function createFormMachine<
  TFields extends Record<string, any>,
  TErrors extends Record<string, string | null>
>({
  initialValues,
  validate
}: {
  initialValues: TFields;
  validate: (values: TFields) => TErrors;
}) {
  // Define our form states
  const states = matchbox({
    Pristine: () => ({
      values: initialValues,
      touched: Object.keys(initialValues).reduce((acc, key) => {
        acc[key] = false;
        return acc;
      }, {} as Record<keyof TFields, boolean>),
      errors: {} as Partial<TErrors>
    }),
    
    Editing: (
      values: TFields,
      touched: Record<keyof TFields, boolean>,
      errors: Partial<TErrors>
    ) => ({
      values,
      touched,
      errors
    }),
    
    Invalid: (
      values: TFields,
      touched: Record<keyof TFields, boolean>,
      errors: TErrors
    ) => ({
      values,
      touched,
      errors
    }),
    
    Submitting: (
      values: TFields
    ) => ({
      values
    }),
    
    Success: (
      values: TFields,
      response?: any
    ) => ({
      values,
      response
    }),
    
    Error: (
      values: TFields,
      error: string
    ) => ({
      values,
      error
    })
  });
  
  // Helper functions for validation state
  function hasErrors(errors: Partial<TErrors>): boolean {
    return Object.values(errors).some(error => error !== null && error !== undefined);
  }
  
  function getErrorsOnly(errors: TErrors): Partial<TErrors> {
    return Object.entries(errors).reduce((acc, [key, value]) => {
      if (value !== null && value !== undefined) {
        acc[key] = value;
      }
      return acc;
    }, {} as Partial<TErrors>);
  }
  
  function touchAll(fields: TFields): Record<keyof TFields, boolean> {
    return Object.keys(fields).reduce((acc, key) => {
      acc[key] = true;
      return acc;
    }, {} as Record<keyof TFields, boolean>);
  }
  
  // Create the form machine
  return matchina(
    states,
    {
      Pristine: {
        // Update a field value
        updateField: <K extends keyof TFields>(
          field: K,
          value: TFields[K],
          state
        ) => {
          const newValues = {
            ...state.data.values,
            [field]: value
          };
          
          const newTouched = {
            ...state.data.touched,
            [field]: true
          };
          
          const errors = validate(newValues);
          const errorsExist = hasErrors(errors);
          
          return {
            key: errorsExist ? "Invalid" : "Editing",
            data: {
              values: newValues,
              touched: newTouched,
              errors: getErrorsOnly(errors)
            }
          };
        },
        
        // Try to submit the pristine form
        submit: (state) => {
          const errors = validate(state.data.values);
          const errorsExist = hasErrors(errors);
          
          if (errorsExist) {
            return {
              key: "Invalid",
              data: {
                values: state.data.values,
                touched: touchAll(state.data.values),
                errors: getErrorsOnly(errors)
              }
            };
          }
          
          return {
            key: "Submitting",
            data: {
              values: state.data.values
            }
          };
        }
      },

      Editing: {
        // Update a field in editing state
        updateField: <K extends keyof TFields>(
          field: K,
          value: TFields[K],
          state
        ) => {
          const newValues = {
            ...state.data.values,
            [field]: value
          };
          
          const newTouched = {
            ...state.data.touched,
            [field]: true
          };
          
          const errors = validate(newValues);
          const errorsExist = hasErrors(errors);
          
          return {
            key: errorsExist ? "Invalid" : "Editing",
            data: {
              values: newValues,
              touched: newTouched,
              errors: getErrorsOnly(errors)
            }
          };
        },
        
        // Submit the form when in editing state
        submit: (state) => {
          const errors = validate(state.data.values);
          const errorsExist = hasErrors(errors);
          
          if (errorsExist) {
            return {
              key: "Invalid",
              data: {
                values: state.data.values,
                touched: touchAll(state.data.values),
                errors: getErrorsOnly(errors)
              }
            };
          }
          
          return {
            key: "Submitting",
            data: {
              values: state.data.values
            }
          };
        },
        
        // Reset the form
        reset: () => ({
          key: "Pristine",
          data: {
            values: initialValues,
            touched: Object.keys(initialValues).reduce((acc, key) => {
              acc[key] = false;
              return acc;
            }, {} as Record<keyof TFields, boolean>),
            errors: {}
          }
        })
      },
      
      Invalid: {
        // Update a field in invalid state
        updateField: <K extends keyof TFields>(
          field: K,
          value: TFields[K],
          state
        ) => {
          const newValues = {
            ...state.data.values,
            [field]: value
          };
          
          const newTouched = {
            ...state.data.touched,
            [field]: true
          };
          
          const errors = validate(newValues);
          const errorsExist = hasErrors(errors);
          
          return {
            key: errorsExist ? "Invalid" : "Editing",
            data: {
              values: newValues,
              touched: newTouched,
              errors: getErrorsOnly(errors)
            }
          };
        },
        
        // Submit the form when in invalid state
        submit: (state) => {
          const errors = validate(state.data.values);
          const errorsExist = hasErrors(errors);
          
          if (errorsExist) {
            return {
              key: "Invalid",
              data: {
                values: state.data.values,
                touched: touchAll(state.data.values),
                errors: getErrorsOnly(errors)
              }
            };
          }
          
          return {
            key: "Submitting",
            data: {
              values: state.data.values
            }
          };
        },
        
        // Reset the form
        reset: () => ({
          key: "Pristine",
          data: {
            values: initialValues,
            touched: Object.keys(initialValues).reduce((acc, key) => {
              acc[key] = false;
              return acc;
            }, {} as Record<keyof TFields, boolean>),
            errors: {}
          }
        })
      },
      
      Submitting: {
        // Submission succeeded
        success: (response, state) => ({
          key: "Success",
          data: {
            values: state.data.values,
            response
          }
        }),
        
        // Submission failed
        error: (errorMessage: string, state) => ({
          key: "Error",
          data: {
            values: state.data.values,
            error: errorMessage
          }
        })
      },
      
      Success: {
        // Reset form after success
        reset: () => ({
          key: "Pristine",
          data: {
            values: initialValues,
            touched: Object.keys(initialValues).reduce((acc, key) => {
              acc[key] = false;
              return acc;
            }, {} as Record<keyof TFields, boolean>),
            errors: {}
          }
        })
      },
      
      Error: {
        // Try submitting again
        submit: (state) => ({
          key: "Submitting",
          data: {
            values: state.data.values
          }
        }),
        
        // Reset form after error
        reset: () => ({
          key: "Pristine",
          data: {
            values: initialValues,
            touched: Object.keys(initialValues).reduce((acc, key) => {
              acc[key] = false;
              return acc;
            }, {} as Record<keyof TFields, boolean>),
            errors: {}
          }
        })
      }
    },
    "Pristine" // Initial state
  );
}
```

## Using the Form Machine Factory

Now let's see how we can use our reusable form machine factory to create a login form:

```ts
// Define a login form with validation
const loginForm = createFormMachine({
  // Initial values
  initialValues: {
    email: "",
    password: ""
  },
  
  // Validation function
  validate: (values) => {
    const errors: Record<string, string | null> = {
      email: null,
      password: null
    };
    
    if (!values.email) {
      errors.email = "Email is required";
    } else if (!/^[A-Z0-9._%+-]+@[A-Z0-9.-]+\.[A-Z]{2,}$/i.test(values.email)) {
      errors.email = "Invalid email address";
    }
    
    if (!values.password) {
      errors.password = "Password is required";
    } else if (values.password.length < 8) {
      errors.password = "Password must be at least 8 characters";
    }
    
    return errors;
  }
});

// Usage example
console.log(loginForm.state.key); // "Pristine"

// Update email field
loginForm.updateField("email", "invalid-email");
console.log(loginForm.state.key); // "Invalid"
console.log(loginForm.state.data.errors.email); // "Invalid email address"

// Update email with valid value
loginForm.updateField("email", "user@example.com");
// Still invalid because password is empty
console.log(loginForm.state.key); // "Invalid"

// Update password
loginForm.updateField("password", "password123");
console.log(loginForm.state.key); // "Editing"

// Submit the form
loginForm.submit();
console.log(loginForm.state.key); // "Submitting"

// In a real app, we would handle form submission asynchronously
// and then call success or error based on the response
setTimeout(() => {
  loginForm.success({ user: { id: 1, name: "User" } });
  console.log(loginForm.state.key); // "Success"
}, 1000);
```

## Creating a Registration Form

The power of our factory is that we can easily create different forms with different validation rules:

```ts
// Define a registration form with different fields and validation
const registrationForm = createFormMachine({
  // Initial values
  initialValues: {
    username: "",
    email: "",
    password: "",
    confirmPassword: ""
  },
  
  // Validation function
  validate: (values) => {
    const errors: Record<string, string | null> = {
      username: null,
      email: null,
      password: null,
      confirmPassword: null
    };
    
    if (!values.username) {
      errors.username = "Username is required";
    } else if (values.username.length < 3) {
      errors.username = "Username must be at least 3 characters";
    }
    
    if (!values.email) {
      errors.email = "Email is required";
    } else if (!/^[A-Z0-9._%+-]+@[A-Z0-9.-]+\.[A-Z]{2,}$/i.test(values.email)) {
      errors.email = "Invalid email address";
    }
    
    if (!values.password) {
      errors.password = "Password is required";
    } else if (values.password.length < 8) {
      errors.password = "Password must be at least 8 characters";
    }
    
    if (!values.confirmPassword) {
      errors.confirmPassword = "Please confirm your password";
    } else if (values.confirmPassword !== values.password) {
      errors.confirmPassword = "Passwords do not match";
    }
    
    return errors;
  }
});
```

## React Integration

Here's how to use our form machine in a React component:

```tsx
import React from "react";
import { useMachine } from "matchina/react";

function LoginForm() {
  const loginMachine = React.useMemo(() => {
    return createFormMachine({
      initialValues: {
        email: "",
        password: ""
      },
      validate: (values) => {
        // Validation logic as defined above
        // ...
      }
    });
  }, []);
  
  // Use the machine in React
  useMachine(loginMachine);
  
  // Form submission handler
  const handleSubmit = async (e: React.FormEvent) => {
    e.preventDefault();
    loginMachine.submit();
    
    if (loginMachine.state.is("Submitting")) {
      try {
        // Simulate API call
        const response = await new Promise(resolve => 
          setTimeout(() => resolve({ user: { id: 1, name: "User" } }), 1000)
        );
        loginMachine.success(response);
      } catch (error) {
        loginMachine.error(error.message);
      }
    }
  };
  
  return (
    <form onSubmit={handleSubmit}>
      <h2>Login</h2>
      
      {/* Display success message */}
      {loginMachine.state.is("Success") && (
        <div className="success">Login successful!</div>
      )}
      
      {/* Display error message */}
      {loginMachine.state.is("Error") && (
        <div className="error">{loginMachine.state.data.error}</div>
      )}
      
      {/* Email field */}
      <div className="form-group">
        <label htmlFor="email">Email</label>
        <input
          id="email"
          type="email"
          value={loginMachine.state.match({
            Pristine: (data) => data.values.email,
            Editing: (data) => data.values.email,
            Invalid: (data) => data.values.email,
            Submitting: (data) => data.values.email,
            Success: (data) => data.values.email,
            Error: (data) => data.values.email
          })}
          onChange={(e) => loginMachine.updateField("email", e.target.value)}
          className={loginMachine.state.match({
            Invalid: (data) => data.touched.email && data.errors.email ? "invalid" : "",
            _: () => ""
          })}
        />
        {loginMachine.state.is("Invalid") && 
         loginMachine.state.data.touched.email && 
         loginMachine.state.data.errors.email && (
          <div className="error-message">{loginMachine.state.data.errors.email}</div>
        )}
      </div>
      
      {/* Password field */}
      <div className="form-group">
        <label htmlFor="password">Password</label>
        <input
          id="password"
          type="password"
          value={loginMachine.state.match({
            Pristine: (data) => data.values.password,
            Editing: (data) => data.values.password,
            Invalid: (data) => data.values.password,
            Submitting: (data) => data.values.password,
            Success: (data) => data.values.password,
            Error: (data) => data.values.password
          })}
          onChange={(e) => loginMachine.updateField("password", e.target.value)}
          className={loginMachine.state.match({
            Invalid: (data) => data.touched.password && data.errors.password ? "invalid" : "",
            _: () => ""
          })}
        />
        {loginMachine.state.is("Invalid") && 
         loginMachine.state.data.touched.password && 
         loginMachine.state.data.errors.password && (
          <div className="error-message">{loginMachine.state.data.errors.password}</div>
        )}
      </div>
      
      {/* Submit button */}
      <button 
        type="submit" 
        disabled={loginMachine.state.is("Submitting")}
      >
        {loginMachine.state.is("Submitting") ? "Logging in..." : "Login"}
      </button>
      
      {/* Reset button */}
      <button 
        type="button"
        onClick={() => loginMachine.reset()}
        disabled={loginMachine.state.is("Submitting")}
      >
        Reset
      </button>
    </form>
  );
}
```

## Benefits of the Form Machine Factory

This reusable form machine factory provides several advantages:

1. **Type Safety**: All form values, errors, and states are fully typed
2. **Reusability**: Create multiple forms with different schemas and validation rules
3. **Consistent Behavior**: All forms follow the same state transition patterns
4. **Separation of Concerns**: Validation logic is separate from UI rendering
5. **Reduced Boilerplate**: No need to reimplement form state management for each form
6. **Predictable UI States**: The state machine ensures forms are always in a valid state

By abstracting the common patterns of form state management into a reusable factory, we've created a powerful pattern that can be applied to any form in an application.
